{"ast":null,"code":"import Direction from \"./Direction\";\nimport Cell from \"./Cell\";\nimport { randint, getPID } from \"./Utils\";\nimport { Color } from \"../../..\";\n\n// A single piece in the game\nclass Piece {\n  constructor(_ref) {\n    var _this = this;\n    let {\n      center_x,\n      center_y,\n      angle,\n      pieceSize,\n      pidSize\n    } = _ref;\n    return function (angle) {\n      [_this.cx, _this.cy, _this.dxn] = [center_x, center_y, new Direction(angle)];\n      _this.pidSize = pidSize;\n      _this.cells = new Map();\n      var [x, y, dxn] = [0, 0, new Direction(randint(0, 4))];\n      var pid = getPID(x, y, pidSize);\n      var turnAngle;\n      var valid;\n      for (var i = 0; i < pieceSize; i++) {\n        valid = false;\n        while (!valid) {\n          _this.cells.set(pid, [x, y]);\n          turnAngle = randint(-1, 2);\n          dxn.turn(turnAngle);\n          x += dxn.dx;\n          y += dxn.dy;\n          pid = getPID(x, y, _this.pidSize);\n          valid = _this.cells.get(pid) == undefined;\n          if (!valid) {\n            x -= dxn.dx;\n            y -= dxn.dy;\n            dxn.turn(-turnAngle);\n          }\n        }\n      }\n\n      // Create 4 different sets to check hitboxes in different gravity\n      _this.collisionSets = [];\n      dxn = new Direction(0);\n      var [x, y] = [0, 0];\n      var collisionSet;\n      for (var angle = 0; angle < 4; angle++) {\n        collisionSet = new Map();\n        _this.cells.forEach(val => {\n          [x, y] = [val[0] + dxn.dx, val[1] + dxn.dy];\n          pid = getPID(x, y, _this.pidSize);\n          collisionSet.set(pid, [x, y]);\n        });\n        _this.collisionSets.push(collisionSet);\n        dxn.turnLeft(1);\n      }\n      _this.color = null;\n      if (angle == 0) {\n        _this.color = new Color();\n      }\n    }(angle);\n  }\n  createCell() {\n    var cell = new Cell(1, {\n      parent: this\n    });\n    return cell;\n  }\n\n  // Return whether or not the block has a collision with this angle.\n  checkCollision(angle, board, boundarySets) {\n    var [xSize, ySize] = [board.length, board[0].length];\n    var collisionSet = this.collisionSets[angle];\n    var boundarySet = boundarySets[angle];\n    var collision = false;\n    // Check for a boundary collision\n    collisionSet.forEach(val => {\n      // BoundarySet has global PIDs\n      // CollisionSet Local PID: add cx and cy to collisionSet to globalize\n      var globalPid = getPID(val[0] + this.cx, val[1] + this.cy, this.pidSize);\n      if (!collision && boundarySet.has(globalPid)) {\n        collision = true;\n      }\n    });\n    if (collision == true) {\n      return true;\n    }\n\n    // Check for a board collision\n    for (var y = 0; y < ySize; y++) {\n      for (var x = 0; x < xSize; x++) {\n        if (board[y][x].type > 0) {\n          // x, y generate global PIDs\n          // Subtract cx and cy from PIDs to localize\n          var globalPid = getPID(x - this.cx, y - this.cy, this.pidSize);\n          if (!collision && collisionSet.has(globalPid)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Move this piece based on a given x and y direction and recheck its appropriate hitbox\n  activeMove(angle) {\n    var adxn = new Direction(angle);\n    this.cx += adxn.dx;\n    this.cy += adxn.dy;\n  }\n\n  // Move this piece based on its gravity and recheck its appropriate hitbox.\n  idleMove() {\n    this.cx += this.dxn.dx;\n    this.cy += this.dxn.dy;\n  }\n}\nexport default Piece;","map":{"version":3,"names":["Direction","Cell","randint","getPID","Color","Piece","constructor","_ref","_this","center_x","center_y","angle","pieceSize","pidSize","cx","cy","dxn","cells","Map","x","y","pid","turnAngle","valid","i","set","turn","dx","dy","get","undefined","collisionSets","collisionSet","forEach","val","push","turnLeft","color","createCell","cell","parent","checkCollision","board","boundarySets","xSize","ySize","length","boundarySet","collision","globalPid","has","type","activeMove","adxn","idleMove"],"sources":["/Users/joeyzhu/code/visuals/pentaquad/src/components/game/gameUtils/Piece.js"],"sourcesContent":["import Direction from \"./Direction\";\nimport Cell from \"./Cell\";\nimport { randint, getPID } from \"./Utils\";\nimport { Color } from \"../../..\"\n\n// A single piece in the game\nclass Piece {\n    constructor({\n        center_x, \n        center_y, \n        angle, \n        pieceSize, \n        pidSize\n    }) {\n        [this.cx, this.cy, this.dxn] = [center_x, center_y, new Direction(angle)];\n        this.pidSize = pidSize;\n\n        this.cells = new Map();\n        var [x, y, dxn] = [0, 0, new Direction(randint(0, 4))];\n        var pid = getPID(x, y, pidSize);\n        var turnAngle;\n        var valid;\n        for (var i = 0; i < pieceSize; i++) {\n            valid = false;\n            while (!valid) {\n                this.cells.set(pid, [x, y])\n                turnAngle = randint(-1, 2)\n                dxn.turn(turnAngle)\n                x += dxn.dx\n                y += dxn.dy\n                pid = getPID(x, y, this.pidSize)\n                valid = this.cells.get(pid) == undefined\n                if (!valid) {\n                    x -= dxn.dx\n                    y -= dxn.dy\n                    dxn.turn(-turnAngle)\n                }\n            }\n        }\n\n        // Create 4 different sets to check hitboxes in different gravity\n        this.collisionSets = [];\n        dxn = new Direction(0);\n        var [x, y] = [0, 0]\n        var collisionSet;\n        for (var angle = 0; angle < 4; angle++) {\n            collisionSet = new Map();\n            this.cells.forEach((val) => {\n                [x, y] = [val[0] + dxn.dx, val[1] + dxn.dy]\n                pid = getPID(x, y, this.pidSize);\n                collisionSet.set(pid, [x, y]);\n            })\n            this.collisionSets.push(collisionSet)\n            dxn.turnLeft(1);\n        }\n\n        this.color = null;\n        if (angle == 0) {\n            this.color = new Color\n        }\n    }\n\n    createCell() {\n        var cell = new Cell(1, {parent: this});\n        return cell;\n    }\n\n    // Return whether or not the block has a collision with this angle.\n    checkCollision(angle, board, boundarySets) {\n\n        var [xSize, ySize] = [board.length, board[0].length];\n        var collisionSet = this.collisionSets[angle];\n        var boundarySet = boundarySets[angle];\n        var collision = false;\n        // Check for a boundary collision\n        collisionSet.forEach((val) => {\n            // BoundarySet has global PIDs\n            // CollisionSet Local PID: add cx and cy to collisionSet to globalize\n            var globalPid = getPID(val[0] + this.cx, val[1] + this.cy, this.pidSize)\n            if (!collision && boundarySet.has(globalPid)) {\n                collision = true;\n            }\n        })\n        if (collision == true) {\n            return true;\n        }\n\n        // Check for a board collision\n        for (var y = 0; y < ySize; y++) {\n            for (var x = 0; x < xSize; x++) {\n                if (board[y][x].type > 0) {\n                    // x, y generate global PIDs\n                    // Subtract cx and cy from PIDs to localize\n                    var globalPid = getPID(x - this.cx, y - this.cy, this.pidSize)\n                    if (!collision && collisionSet.has(globalPid)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    // Move this piece based on a given x and y direction and recheck its appropriate hitbox\n    activeMove(angle) {\n        var adxn = new Direction(angle);\n        this.cx += adxn.dx;\n        this.cy += adxn.dy;\n    }\n\n    // Move this piece based on its gravity and recheck its appropriate hitbox.\n    idleMove() {\n        this.cx += this.dxn.dx;\n        this.cy += this.dxn.dy;\n    }\n}\n\nexport default Piece;"],"mappings":"AAAA,OAAOA,SAAS,MAAM,aAAa;AACnC,OAAOC,IAAI,MAAM,QAAQ;AACzB,SAASC,OAAO,EAAEC,MAAM,QAAQ,SAAS;AACzC,SAASC,KAAK,QAAQ,UAAU;;AAEhC;AACA,MAAMC,KAAK,CAAC;EACRC,WAAWA,CAAAC,IAAA;IAAA,IAAAC,KAAA;IAAA,IAAC;MACRC,QAAQ;MACRC,QAAQ;MACRC,KAAK;MACLC,SAAS;MACTC;IACJ,CAAC,GAAAN,IAAA;IAAA,iBAAAI,KAAA,EAAE;MACC,CAACH,KAAI,CAACM,EAAE,EAAEN,KAAI,CAACO,EAAE,EAAEP,KAAI,CAACQ,GAAG,CAAC,GAAG,CAACP,QAAQ,EAAEC,QAAQ,EAAE,IAAIV,SAAS,CAACW,KAAK,CAAC,CAAC;MACzEH,KAAI,CAACK,OAAO,GAAGA,OAAO;MAEtBL,KAAI,CAACS,KAAK,GAAG,IAAIC,GAAG,EAAE;MACtB,IAAI,CAACC,CAAC,EAAEC,CAAC,EAAEJ,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,IAAIhB,SAAS,CAACE,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;MACtD,IAAImB,GAAG,GAAGlB,MAAM,CAACgB,CAAC,EAAEC,CAAC,EAAEP,OAAO,CAAC;MAC/B,IAAIS,SAAS;MACb,IAAIC,KAAK;MACT,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,SAAS,EAAEY,CAAC,EAAE,EAAE;QAChCD,KAAK,GAAG,KAAK;QACb,OAAO,CAACA,KAAK,EAAE;UACXf,KAAI,CAACS,KAAK,CAACQ,GAAG,CAACJ,GAAG,EAAE,CAACF,CAAC,EAAEC,CAAC,CAAC,CAAC;UAC3BE,SAAS,GAAGpB,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;UAC1Bc,GAAG,CAACU,IAAI,CAACJ,SAAS,CAAC;UACnBH,CAAC,IAAIH,GAAG,CAACW,EAAE;UACXP,CAAC,IAAIJ,GAAG,CAACY,EAAE;UACXP,GAAG,GAAGlB,MAAM,CAACgB,CAAC,EAAEC,CAAC,EAAEZ,KAAI,CAACK,OAAO,CAAC;UAChCU,KAAK,GAAGf,KAAI,CAACS,KAAK,CAACY,GAAG,CAACR,GAAG,CAAC,IAAIS,SAAS;UACxC,IAAI,CAACP,KAAK,EAAE;YACRJ,CAAC,IAAIH,GAAG,CAACW,EAAE;YACXP,CAAC,IAAIJ,GAAG,CAACY,EAAE;YACXZ,GAAG,CAACU,IAAI,CAAC,CAACJ,SAAS,CAAC;UACxB;QACJ;MACJ;;MAEA;MACAd,KAAI,CAACuB,aAAa,GAAG,EAAE;MACvBf,GAAG,GAAG,IAAIhB,SAAS,CAAC,CAAC,CAAC;MACtB,IAAI,CAACmB,CAAC,EAAEC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;MACnB,IAAIY,YAAY;MAChB,KAAK,IAAIrB,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,CAAC,EAAEA,KAAK,EAAE,EAAE;QACpCqB,YAAY,GAAG,IAAId,GAAG,EAAE;QACxBV,KAAI,CAACS,KAAK,CAACgB,OAAO,CAAEC,GAAG,IAAK;UACxB,CAACf,CAAC,EAAEC,CAAC,CAAC,GAAG,CAACc,GAAG,CAAC,CAAC,CAAC,GAAGlB,GAAG,CAACW,EAAE,EAAEO,GAAG,CAAC,CAAC,CAAC,GAAGlB,GAAG,CAACY,EAAE,CAAC;UAC3CP,GAAG,GAAGlB,MAAM,CAACgB,CAAC,EAAEC,CAAC,EAAEZ,KAAI,CAACK,OAAO,CAAC;UAChCmB,YAAY,CAACP,GAAG,CAACJ,GAAG,EAAE,CAACF,CAAC,EAAEC,CAAC,CAAC,CAAC;QACjC,CAAC,CAAC;QACFZ,KAAI,CAACuB,aAAa,CAACI,IAAI,CAACH,YAAY,CAAC;QACrChB,GAAG,CAACoB,QAAQ,CAAC,CAAC,CAAC;MACnB;MAEA5B,KAAI,CAAC6B,KAAK,GAAG,IAAI;MACjB,IAAI1B,KAAK,IAAI,CAAC,EAAE;QACZH,KAAI,CAAC6B,KAAK,GAAG,IAAIjC,KAAK;MAC1B;IACJ,CAAC,CAAAO,KAAA;EAAA;EAED2B,UAAUA,CAAA,EAAG;IACT,IAAIC,IAAI,GAAG,IAAItC,IAAI,CAAC,CAAC,EAAE;MAACuC,MAAM,EAAE;IAAI,CAAC,CAAC;IACtC,OAAOD,IAAI;EACf;;EAEA;EACAE,cAAcA,CAAC9B,KAAK,EAAE+B,KAAK,EAAEC,YAAY,EAAE;IAEvC,IAAI,CAACC,KAAK,EAAEC,KAAK,CAAC,GAAG,CAACH,KAAK,CAACI,MAAM,EAAEJ,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM,CAAC;IACpD,IAAId,YAAY,GAAG,IAAI,CAACD,aAAa,CAACpB,KAAK,CAAC;IAC5C,IAAIoC,WAAW,GAAGJ,YAAY,CAAChC,KAAK,CAAC;IACrC,IAAIqC,SAAS,GAAG,KAAK;IACrB;IACAhB,YAAY,CAACC,OAAO,CAAEC,GAAG,IAAK;MAC1B;MACA;MACA,IAAIe,SAAS,GAAG9C,MAAM,CAAC+B,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAACpB,EAAE,EAAEoB,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAACnB,EAAE,EAAE,IAAI,CAACF,OAAO,CAAC;MACxE,IAAI,CAACmC,SAAS,IAAID,WAAW,CAACG,GAAG,CAACD,SAAS,CAAC,EAAE;QAC1CD,SAAS,GAAG,IAAI;MACpB;IACJ,CAAC,CAAC;IACF,IAAIA,SAAS,IAAI,IAAI,EAAE;MACnB,OAAO,IAAI;IACf;;IAEA;IACA,KAAK,IAAI5B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyB,KAAK,EAAEzB,CAAC,EAAE,EAAE;MAC5B,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyB,KAAK,EAAEzB,CAAC,EAAE,EAAE;QAC5B,IAAIuB,KAAK,CAACtB,CAAC,CAAC,CAACD,CAAC,CAAC,CAACgC,IAAI,GAAG,CAAC,EAAE;UACtB;UACA;UACA,IAAIF,SAAS,GAAG9C,MAAM,CAACgB,CAAC,GAAG,IAAI,CAACL,EAAE,EAAEM,CAAC,GAAG,IAAI,CAACL,EAAE,EAAE,IAAI,CAACF,OAAO,CAAC;UAC9D,IAAI,CAACmC,SAAS,IAAIhB,YAAY,CAACkB,GAAG,CAACD,SAAS,CAAC,EAAE;YAC3C,OAAO,IAAI;UACf;QACJ;MACJ;IACJ;IAEA,OAAO,KAAK;EAChB;;EAEA;EACAG,UAAUA,CAACzC,KAAK,EAAE;IACd,IAAI0C,IAAI,GAAG,IAAIrD,SAAS,CAACW,KAAK,CAAC;IAC/B,IAAI,CAACG,EAAE,IAAIuC,IAAI,CAAC1B,EAAE;IAClB,IAAI,CAACZ,EAAE,IAAIsC,IAAI,CAACzB,EAAE;EACtB;;EAEA;EACA0B,QAAQA,CAAA,EAAG;IACP,IAAI,CAACxC,EAAE,IAAI,IAAI,CAACE,GAAG,CAACW,EAAE;IACtB,IAAI,CAACZ,EAAE,IAAI,IAAI,CAACC,GAAG,CAACY,EAAE;EAC1B;AACJ;AAEA,eAAevB,KAAK"},"metadata":{},"sourceType":"module","externalDependencies":[]}