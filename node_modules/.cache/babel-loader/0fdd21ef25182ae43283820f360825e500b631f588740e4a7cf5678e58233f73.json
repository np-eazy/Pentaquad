{"ast":null,"code":"const GameState = class {\n  constructor(_ref) {\n    let {} = _ref;\n    this.timer = 0;\n    this.smoothGrid = emptyGrid();\n    this.totalGrid = emptyGrid();\n    this.gridStream = [emptyGrid()];\n    this.currGridBufferSize = 1;\n    this.canvasSize = [G1[X] - G0[X], G1[Y] - G0[Y]];\n    this.ticks = 0;\n    this.mainGrid = emptyGrid();\n    this.vxGrid = emptyGrid();\n    this.vyGrid = emptyGrid();\n  }\n  addGridFrame(newGrid) {\n    // Add to the total grid\n    this.totalGrid.add(newGrid);\n    if (this.currGridBufferSize == MAX_GRID_BUFFER_SIZE) {\n      // If buffer is full, take out bottom of stream and set values to incoming grid\n      // And recalculate sliding total\n      var last = this.gridStream.shift();\n      this.totalGrid.subtract(last);\n      newGrid.copyTo(last);\n      this.gridStream.push(last);\n    } else {\n      // If buffer isn't full, add a copy of current and up counter\n      var newArr = emptyGrid();\n      newGrid.copyTo(newArr);\n      this.gridStream.push(newArr);\n      this.currGridBufferSize++;\n    }\n    this.smoothGrid.interpolate(this.totalGrid.createScale(1 / this.currGridBufferSize), MOVE_RATE);\n  }\n  pull(grid, center, target, range) {\n    center[X] = Math.floor(center[X]);\n    center[Y] = Math.floor(center[Y]);\n    var ax = Math.max(0, center[X] - range);\n    var bx = Math.min(grid.xSize - 1, center[X] + range + 1);\n    var ay = Math.max(0, center[Y] - range);\n    var by = Math.min(grid.ySize - 1, center[Y] + range + 1);\n    for (var x = ax; x <= bx; x++) {\n      for (var y = ay; y <= by; y++) {\n        var dx = x - center[X];\n        var dy = y - center[Y];\n        var r2 = dx * dx + dy * dy;\n        grid.setVal(x, y, interpolate(grid.getVal(x, y), target, FLUCTUATION_MAGNITUDE / (r2 + 1)));\n      }\n    }\n  }\n  update(increment) {}\n  executeAction(action) {\n    console.log(action);\n    return this;\n  }\n};\nexport default GameState;","map":{"version":3,"names":["GameState","constructor","_ref","timer","smoothGrid","emptyGrid","totalGrid","gridStream","currGridBufferSize","canvasSize","G1","X","G0","Y","ticks","mainGrid","vxGrid","vyGrid","addGridFrame","newGrid","add","MAX_GRID_BUFFER_SIZE","last","shift","subtract","copyTo","push","newArr","interpolate","createScale","MOVE_RATE","pull","grid","center","target","range","Math","floor","ax","max","bx","min","xSize","ay","by","ySize","x","y","dx","dy","r2","setVal","getVal","FLUCTUATION_MAGNITUDE","update","increment","executeAction","action","console","log"],"sources":["/Users/joeyzhu/code/visuals/pentaquad/src/components/game/GameState.js"],"sourcesContent":["\n\nconst GameState = class {\n    constructor ({}) {\n        this.timer = 0;\n        this.smoothGrid = emptyGrid();\n        this.totalGrid = emptyGrid();\n        this.gridStream = [emptyGrid()];\n\n        this.currGridBufferSize = 1;\n        this.canvasSize = [G1[X] - G0[X], G1[Y] - G0[Y]];\n        this.ticks = 0;\n\n        this.mainGrid = emptyGrid();\n        this.vxGrid = emptyGrid();\n        this.vyGrid = emptyGrid();\n    }\n\n    addGridFrame(newGrid) {\n        // Add to the total grid\n        this.totalGrid.add(newGrid);\n        \n        if (this.currGridBufferSize == MAX_GRID_BUFFER_SIZE) {\n            // If buffer is full, take out bottom of stream and set values to incoming grid\n            // And recalculate sliding total\n            var last = this.gridStream.shift();\n            this.totalGrid.subtract(last);\n            newGrid.copyTo(last);\n            this.gridStream.push(last);\n\n        } else {\n            // If buffer isn't full, add a copy of current and up counter\n            var newArr = emptyGrid();\n            newGrid.copyTo(newArr);\n            this.gridStream.push(newArr);\n            this.currGridBufferSize++;\n        }\n        \n        this.smoothGrid.interpolate(\n            this.totalGrid.createScale(1 / this.currGridBufferSize),\n            MOVE_RATE\n        );\n    }\n\n    pull(grid, center, target, range) {\n        center[X] = Math.floor(center[X]);\n        center[Y] = Math.floor(center[Y]);\n        var ax = Math.max(0, center[X] - range);\n        var bx = Math.min(grid.xSize - 1, (center[X] + range) + 1);\n        var ay = Math.max(0, center[Y] - range);\n        var by = Math.min(grid.ySize - 1, (center[Y] + range) + 1);\n        for (var x = ax; x <= bx; x++) {\n            for (var y = ay; y <= by; y++) {\n                var dx = x - center[X];\n                var dy = y - center[Y];\n                var r2 = dx * dx + dy * dy;\n                grid.setVal(x, y, \n                    interpolate(grid.getVal(x, y), target, \n                        FLUCTUATION_MAGNITUDE / (r2 + 1)\n                    )\n                );\n            }\n        }\n    }\n\n    update(increment) {\n\n    }\n\n    executeAction(action) {\n        console.log(action);\n        return this;\n    }\n}\n\nexport default GameState;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}