{"ast":null,"code":"import Cell from \"./Cell\";\nimport { randint, getPID, Direction, DXN, NULL_DXN } from \"./Utils\";\nimport { Color } from \"../graphics/Colors\";\n\n// A single piece in the game, which can move in different directions and detect collisions\n// based on which direction is moving.\nclass Piece {\n  constructor(_ref) {\n    let {\n      center_x,\n      center_y,\n      angle,\n      pieceSize,\n      pidSize\n    } = _ref;\n    [this.cx, this.cy, this.dxn] = [center_x, center_y, new Direction(angle)];\n    this.pidSize = pidSize;\n\n    // Create some arrangement of 5 contiguous cells.\n    // TODO: It would be faster/easier to pull from a set of all possible existing cells\n    this.cells = new Map();\n    var [x, y, dxn] = [0, 0, new Direction(randint(0, 4))];\n    var pid = getPID(x, y, pidSize);\n    var turnAngle;\n    var valid;\n    for (var i = 0; i < pieceSize; i++) {\n      valid = false;\n      while (!valid) {\n        this.cells.set(pid, [x, y]);\n        turnAngle = randint(-1, 2);\n        dxn.turn(turnAngle);\n        x += dxn.dx;\n        y += dxn.dy;\n        pid = getPID(x, y, this.pidSize);\n        valid = this.cells.get(pid) == undefined;\n        if (!valid) {\n          x -= dxn.dx;\n          y -= dxn.dy;\n          dxn.turn(-turnAngle);\n        }\n      }\n    }\n    // Set this piece's color based on its initial direction; there will be more\n    // room to customize this.\n    if (angle % 4 == DXN.RIGHT) {\n      this.color = new Color({\n        red: 225,\n        green: 0,\n        blue: 105\n      });\n    } else if (angle % 4 == DXN.UP) {\n      this.color = new Color({\n        red: 255,\n        green: 125,\n        blue: 0\n      });\n    } else if (angle % 4 == DXN.LEFT) {\n      this.color = new Color({\n        red: 0,\n        green: 235,\n        blue: 175\n      });\n    } else if (angle % 4 == DXN.DOWN) {\n      this.color = new Color({\n        red: 0,\n        green: 200,\n        blue: 235\n      });\n    }\n  }\n\n  // The function to fill the coreState with cells corresponding to this Piece; this will\n  // be used for cases like the render script accessing the color in the parents\n  createCell() {\n    var cell = new Cell(1, {\n      parent: this\n    });\n    return cell;\n  }\n\n  // Return whether or not the block has a collision with this angle.\n  // Null angle option is for rotation collision check, only to make sure that the piece\n  // doesn't rotate into any overlaps with filled cells.\n  checkCollision(angle, board, boundarySets) {\n    var [xSize, ySize] = [board.length, board[0].length];\n    var collisionDxn = angle == null ? {\n      dx: 0,\n      dy: 0\n    } : new Direction(angle);\n    var boundarySet = angle == null ? new Set() : boundarySets[angle];\n    var collision = false;\n\n    // Check for a boundary collision\n    this.cells.forEach(val => {\n      var globalPid = getPID(val[0] + this.cx + collisionDxn.dx, val[1] + this.cy + collisionDxn.dy, this.pidSize);\n      if (!collision && boundarySet.has(globalPid)) {\n        collision = true;\n      }\n    });\n    if (collision == true) {\n      return true;\n    }\n\n    // Check for a board collision\n    for (var y = 0; y < ySize; y++) {\n      for (var x = 0; x < xSize; x++) {\n        if (board[y][x].type > 0) {\n          // x, y generate global PIDs\n          // Subtract cx and cy from PIDs to localize\n          var globalPid = getPID(x - this.cx - collisionDxn.dx, y - this.cy - collisionDxn.dy, this.pidSize);\n          if (!collision && this.cells.has(globalPid)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Move this piece based on a given x and y direction and recheck its appropriate hitbox\n  activeMove(angle) {\n    var adxn = new Direction(angle);\n    this.cx += adxn.dx;\n    this.cy += adxn.dy;\n  }\n\n  // Move this piece based on its gravity and recheck its appropriate hitbox.\n  idleMove() {\n    this.cx += this.dxn.dx;\n    this.cy += this.dxn.dy;\n  }\n  rotate(angle) {\n    if (angle < 0) {\n      console.log(angle);\n      this.signedRotate(angle, -1);\n    } else {\n      this.signedRotate(angle, 1);\n    }\n  }\n  signedRotate(turns, sign) {\n    for (var t = 0; t < turns % 4; t++) {\n      var newCells = new Map();\n      this.cells.forEach(val => {\n        var [newX, newY] = [-val[1] * sign, val[0] * sign];\n        var pid = getPID(newX, newY, this.pidSize);\n        newCells.set(pid, [newX, newY]);\n      });\n      this.cells = newCells;\n    }\n  }\n}\nexport default Piece;","map":{"version":3,"names":["Cell","randint","getPID","Direction","DXN","NULL_DXN","Color","Piece","constructor","_ref","center_x","center_y","angle","pieceSize","pidSize","cx","cy","dxn","cells","Map","x","y","pid","turnAngle","valid","i","set","turn","dx","dy","get","undefined","RIGHT","color","red","green","blue","UP","LEFT","DOWN","createCell","cell","parent","checkCollision","board","boundarySets","xSize","ySize","length","collisionDxn","boundarySet","Set","collision","forEach","val","globalPid","has","type","activeMove","adxn","idleMove","rotate","console","log","signedRotate","turns","sign","t","newCells","newX","newY"],"sources":["/Users/joeyzhu/code/Pentaquad/src/components/game/coreState/Piece.js"],"sourcesContent":["import Cell from \"./Cell\";\nimport { randint, getPID, Direction, DXN, NULL_DXN } from \"./Utils\";\nimport { Color } from \"../graphics/Colors\";\n\n// A single piece in the game, which can move in different directions and detect collisions\n// based on which direction is moving.\nclass Piece {\n    constructor({\n        center_x, \n        center_y, \n        angle, \n        pieceSize, \n        pidSize\n    }) {\n        [this.cx, this.cy, this.dxn] = [center_x, center_y, new Direction(angle)];\n        this.pidSize = pidSize;\n\n        // Create some arrangement of 5 contiguous cells.\n        // TODO: It would be faster/easier to pull from a set of all possible existing cells\n        this.cells = new Map();\n        var [x, y, dxn] = [0, 0, new Direction(randint(0, 4))];\n        var pid = getPID(x, y, pidSize);\n        var turnAngle;\n        var valid;\n        for (var i = 0; i < pieceSize; i++) {\n            valid = false;\n            while (!valid) {\n                this.cells.set(pid, [x, y])\n                turnAngle = randint(-1, 2)\n                dxn.turn(turnAngle)\n                x += dxn.dx\n                y += dxn.dy\n                pid = getPID(x, y, this.pidSize)\n                valid = this.cells.get(pid) == undefined\n                if (!valid) {\n                    x -= dxn.dx\n                    y -= dxn.dy\n                    dxn.turn(-turnAngle)\n                }\n            }\n        }\n        // Set this piece's color based on its initial direction; there will be more\n        // room to customize this.\n        if (angle % 4 == DXN.RIGHT) {\n            this.color = new Color({ red: 225, green: 0, blue: 105})\n        } else if (angle % 4 == DXN.UP) {\n            this.color = new Color({ red: 255, green: 125, blue: 0})\n        } else if (angle % 4 == DXN.LEFT) {\n            this.color = new Color({ red: 0, green: 235, blue: 175})\n        } else if (angle % 4 == DXN.DOWN) {\n            this.color = new Color({ red: 0, green: 200, blue: 235})\n        }  \n    }\n\n    // The function to fill the coreState with cells corresponding to this Piece; this will\n    // be used for cases like the render script accessing the color in the parents\n    createCell() {\n        var cell = new Cell(1, {parent: this});\n        return cell;\n    }\n\n    // Return whether or not the block has a collision with this angle.\n    // Null angle option is for rotation collision check, only to make sure that the piece\n    // doesn't rotate into any overlaps with filled cells.\n    checkCollision(angle, board, boundarySets) {\n        var [xSize, ySize] = [board.length, board[0].length];\n\n        var collisionDxn = angle == null ? { dx: 0, dy: 0 } : new Direction(angle)\n        var boundarySet = angle == null ? new Set() : boundarySets[angle];\n        var collision = false;\n\n        // Check for a boundary collision\n        this.cells.forEach((val) => {\n            var globalPid = getPID(\n                val[0] + this.cx + collisionDxn.dx, \n                val[1] + this.cy + collisionDxn.dy, \n                this.pidSize)\n            if (!collision && boundarySet.has(globalPid)) {\n                collision = true;\n            }\n        })\n        if (collision == true) {\n            return true;\n        }\n\n        // Check for a board collision\n        for (var y = 0; y < ySize; y++) {\n            for (var x = 0; x < xSize; x++) {\n                if (board[y][x].type > 0) {\n                    // x, y generate global PIDs\n                    // Subtract cx and cy from PIDs to localize\n                    var globalPid = getPID(\n                        x - this.cx - collisionDxn.dx, \n                        y - this.cy - collisionDxn.dy, \n                        this.pidSize)\n                    if (!collision && this.cells.has(globalPid)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    // Move this piece based on a given x and y direction and recheck its appropriate hitbox\n    activeMove(angle) {\n        var adxn = new Direction(angle);\n        this.cx += adxn.dx;\n        this.cy += adxn.dy;\n    }\n\n    // Move this piece based on its gravity and recheck its appropriate hitbox.\n    idleMove() {\n        this.cx += this.dxn.dx;\n        this.cy += this.dxn.dy;\n    }\n\n    rotate(angle) {\n        if (angle < 0) {\n            console.log(angle)\n\n            this.signedRotate(angle, -1)\n        } else {\n            this.signedRotate(angle, 1)\n        }\n    }\n\n    signedRotate(turns, sign) {\n        for (var t = 0; t < turns % 4; t++) {\n            var newCells = new Map()\n            this.cells.forEach((val) => {\n                var [newX, newY] = [-val[1] * sign, val[0] * sign]\n                var pid = getPID(newX, newY, this.pidSize)\n                newCells.set(pid, [newX, newY])\n            })\n            this.cells = newCells\n        }\n    }\n}\n\nexport default Piece;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}