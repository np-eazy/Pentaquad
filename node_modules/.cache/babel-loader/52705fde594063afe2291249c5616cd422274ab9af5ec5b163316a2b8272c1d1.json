{"ast":null,"code":"import Direction from \"./Direction\";\n\n// Placeholder for more complex mechanisms\nclass Cell {\n  constructor(type, id) {\n    this.type = type;\n  }\n}\n\n// Generate a random integer from a up to but not including b\nfunction randint(a, b) {\n  return Math.floor(Math.random() * (b - a)) + a;\n}\n\n// Generate a unique int of coordinate x, y given a maximum groupSize, in order\n// to create a set of unique x, y values\nfunction getPID(x, y, groupSize) {\n  return x * groupSize + y;\n}\nclass Piece {\n  constructor(_ref) {\n    var _this = this;\n    let {\n      center_x,\n      center_y,\n      angle,\n      pieceSize,\n      boardXSize,\n      boardYSize,\n      pidSize\n    } = _ref;\n    return function (angle) {\n      [_this.cx, _this.cy] = [center_x, center_y];\n      _this.angle = angle;\n      _this.dxn = new Direction(angle);\n      _this.collisionFlag = false;\n      _this.pidSize = pidSize;\n\n      // Create a set of actual cells, to be offset by cx and cy\n      _this.cells = new Map();\n      var [x, y, dxn] = [0, 0, new Direction(randint(0, 4))];\n      var pid = getPID(x, y, _this.pidSize);\n      for (var i = 0; i < pieceSize; i++) {\n        var valid = false;\n        while (!valid) {\n          _this.cells.set([x, y], pid);\n          var turnAngle = randint(-1, 2);\n          dxn.turn(turnAngle);\n          x += dxn.dx;\n          y += dxn.dy;\n          pid = getPID(x, y, _this.pidSize);\n          if (_this.cells.get(pid) == undefined) {\n            valid = true;\n          } else {\n            valid = false;\n            x -= dxn.dx;\n            y -= dxn.dy;\n            dxn.turn(-turnAngle);\n          }\n        }\n      }\n\n      // Create 4 different sets to check hitboxes in different gravity\n      _this.collisionSets = [];\n      dxn = new Direction(0);\n      var [x, y] = [0, 0];\n      for (var angle = 0; angle < 4; angle++) {\n        var collisionSet = new Map();\n        _this.cells.forEach((key, val) => {\n          var x_ = val[0] += dxn.dx;\n          var y_ = val[1] += dxn.dy;\n          pid = getPID(x_, y_, _this.pidSize);\n          collisionSet.set([x_, y_], pid);\n        });\n        _this.collisionSets.push(collisionSet);\n        dxn.turnLeft(1);\n      }\n\n      // Create 4 different sets to check if a boundary has been hit\n      var [xSize, ySize] = [boardXSize, boardYSize];\n      _this.boundarySets = [];\n      var boundarySet = new Map();\n      for (var y = 0; y < ySize; y++) {\n        pid = getPID(xSize, y, _this.pidSize);\n        boundarySet.set([xSize, y], pid);\n      }\n      _this.boundarySets.push(boundarySet);\n      boundarySet = new Map();\n      for (var x = 0; x < xSize; x++) {\n        pid = getPID(x, -1, _this.pidSize);\n        boundarySet.set([x, -1], pid);\n      }\n      _this.boundarySets.push(boundarySet);\n      boundarySet = new Map();\n      for (var y = 0; y < ySize; y++) {\n        pid = getPID(-1, y, _this.pidSize);\n        boundarySet.set([-1, y], pid);\n      }\n      _this.boundarySets.push(boundarySet);\n      boundarySet = new Map();\n      for (var x = 0; x < xSize; x++) {\n        pid = getPID(x, ySize, _this.pidSize);\n        boundarySet.set([x, ySize], pid);\n      }\n      _this.boundarySets.push(boundarySet);\n\n      // Placeholder for setting different types/properties of this piece.\n      if (angle == 0) {\n        _this.type = 1;\n      } else if (angle == 1) {\n        _this.type = 2;\n      } else if (angle == 1) {\n        _this.type = 3;\n      } else if (angle == 1) {\n        _this.type = 4;\n      }\n    }(angle);\n  }\n\n  // Return whether or not the block has a collision with this angle.\n  checkCollision(angle, board) {\n    var [xSize, ySize] = [board.length, board[0].length];\n    var collisionSet = this.collisionSets[angle];\n    var boundarySet = this.boundarySets[angle];\n    // Check for a boundary collision\n    var collision = false;\n    console.log(collisionSet);\n    collisionSet.forEach((pid, _ref2) => {\n      let [x, y] = _ref2;\n      var globalPid = getPID(x, y, this.pidSize);\n      console.log(globalPid);\n      if (!collision && boundarySet.has(globalPid)) {\n        collision = true;\n      }\n    });\n    if (collision == true) return true;\n\n    // Check for a board collision\n    for (var y = 0; y < ySize; y++) {\n      for (var x = 0; x < xSize; x++) {\n        if (board[y][x] > 0) {\n          var globalPid = getPID(x, y, this.pidSize);\n          if (!collision && collisionSet.has(globalPid)) {\n            return true;\n          }\n          // TODO: Add room for more abstract collision logic and properties\n        }\n      }\n    }\n\n    return false;\n  }\n\n  // Move this piece based on a given x and y direction and recheck its appropriate hitbox\n  activeMove(angle) {\n    var dxn = new Direction(angle);\n  }\n\n  // Move this piece based on its gravity and recheck its appropriate hitbox.\n  idleMove() {\n    this.cx += this.dxn.dx;\n    this.cy += this.dxn.dy;\n  }\n}\nexport default Piece;","map":{"version":3,"names":["Direction","Cell","constructor","type","id","randint","a","b","Math","floor","random","getPID","x","y","groupSize","Piece","_ref","_this","center_x","center_y","angle","pieceSize","boardXSize","boardYSize","pidSize","cx","cy","dxn","collisionFlag","cells","Map","pid","i","valid","set","turnAngle","turn","dx","dy","get","undefined","collisionSets","collisionSet","forEach","key","val","x_","y_","push","turnLeft","xSize","ySize","boundarySets","boundarySet","checkCollision","board","length","collision","console","log","_ref2","globalPid","has","activeMove","idleMove"],"sources":["/Users/joeyzhu/code/visuals/pentaquad/src/components/game/gameUtils/Piece.js"],"sourcesContent":["import Direction from \"./Direction\";\n\n// Placeholder for more complex mechanisms\nclass Cell {\n    constructor(type, id) {\n        this.type = type\n    }\n}\n\n// Generate a random integer from a up to but not including b\nfunction randint(a, b) {\n    return Math.floor(Math.random() * (b - a)) + a;\n}\n\n// Generate a unique int of coordinate x, y given a maximum groupSize, in order\n// to create a set of unique x, y values\nfunction getPID(x, y, groupSize) {\n    return x * groupSize + y;\n}\n\nclass Piece {\n    constructor({center_x, center_y, angle, pieceSize, boardXSize, boardYSize, pidSize}) {\n        [this.cx, this.cy] = [center_x, center_y];\n\n        this.angle = angle;\n        this.dxn = new Direction(angle);\n        this.collisionFlag = false;\n        this.pidSize = pidSize;\n\n        // Create a set of actual cells, to be offset by cx and cy\n        this.cells = new Map();\n        var [x, y, dxn] = [0, 0, new Direction(randint(0, 4))];\n        var pid = getPID(x, y, this.pidSize);\n        for (var i = 0; i < pieceSize; i++) {\n            var valid = false;\n            while (!valid) {\n                this.cells.set([x, y], pid)\n                var turnAngle = randint(-1, 2)\n                dxn.turn(turnAngle)\n                x += dxn.dx\n                y += dxn.dy\n                pid = getPID(x, y, this.pidSize)\n                \n                if (this.cells.get(pid) == undefined) {\n                    valid = true\n                } else {\n                    valid = false\n                    x -= dxn.dx\n                    y -= dxn.dy\n                    dxn.turn(-turnAngle)\n                }\n            }\n        }\n\n        // Create 4 different sets to check hitboxes in different gravity\n        this.collisionSets = [];\n        dxn = new Direction(0);\n        var [x, y] = [0, 0]\n        for (var angle = 0; angle < 4; angle++) {\n            var collisionSet = new Map();\n\n            this.cells.forEach((key, val) => {\n                var x_ = val[0] += dxn.dx\n                var y_ = val[1] += dxn.dy\n                pid = getPID(x_, y_, this.pidSize);\n                collisionSet.set([x_, y_], pid);\n            })\n\n            this.collisionSets.push(collisionSet)\n            dxn.turnLeft(1);\n        }\n\n        // Create 4 different sets to check if a boundary has been hit\n        var [xSize, ySize] = [boardXSize, boardYSize]\n        this.boundarySets = [];\n        var boundarySet = new Map()\n        for (var y = 0; y < ySize; y++) {\n            pid = getPID(xSize, y, this.pidSize);\n            boundarySet.set([xSize, y], pid)\n        }\n        this.boundarySets.push(boundarySet);\n\n        boundarySet = new Map()\n        for (var x = 0; x < xSize; x++) {\n            pid = getPID(x, -1, this.pidSize);\n            boundarySet.set([x, -1], pid)\n        }\n        this.boundarySets.push(boundarySet);\n\n        boundarySet = new Map()\n        for (var y = 0; y < ySize; y++) {\n            pid = getPID(-1, y, this.pidSize);\n            boundarySet.set([-1, y], pid)\n        }\n        this.boundarySets.push(boundarySet);\n\n        boundarySet = new Map()\n        for (var x = 0; x < xSize; x++) {\n            pid = getPID(x, ySize, this.pidSize);\n            boundarySet.set([x, ySize], pid)\n        }\n        this.boundarySets.push(boundarySet);\n        \n        // Placeholder for setting different types/properties of this piece.\n        if (angle == 0) {\n            this.type = 1;\n        } else if (angle == 1) {\n            this.type = 2;\n        } else if (angle == 1) {\n            this.type = 3;\n        } else if (angle == 1) {\n            this.type = 4;\n        }\n    }\n\n    // Return whether or not the block has a collision with this angle.\n    checkCollision(angle, board) {\n        var [xSize, ySize] = [board.length, board[0].length];\n        var collisionSet = this.collisionSets[angle];\n        var boundarySet = this.boundarySets[angle];\n        // Check for a boundary collision\n        var collision = false;\n        console.log(collisionSet)\n        collisionSet.forEach((pid, [x, y]) => {\n            var globalPid = getPID(x, y, this.pidSize)\n            console.log(globalPid)\n            if (!collision && boundarySet.has(globalPid)) {\n                collision = true;\n            }\n        })\n        if (collision == true) return true;\n\n        // Check for a board collision\n        for (var y = 0; y < ySize; y++) {\n            for (var x = 0; x < xSize; x++) {\n                if (board[y][x] > 0) {\n                    var globalPid = getPID(x, y, this.pidSize)\n                    if (!collision && collisionSet.has(globalPid)) {\n                        return true;\n                    }\n                    // TODO: Add room for more abstract collision logic and properties\n                }\n            }\n        }\n\n        return false;\n    }\n\n    // Move this piece based on a given x and y direction and recheck its appropriate hitbox\n    activeMove(angle) {\n        var dxn = new Direction(angle);\n    }\n\n    // Move this piece based on its gravity and recheck its appropriate hitbox.\n    idleMove() {\n        this.cx += this.dxn.dx;\n        this.cy += this.dxn.dy;\n    }\n}\n\nexport default Piece;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}