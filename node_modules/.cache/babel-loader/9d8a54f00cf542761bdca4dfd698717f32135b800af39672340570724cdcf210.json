{"ast":null,"code":"const ActionType = {\n  MOVE: 0,\n  ROTATE: 1,\n  PLACE: 2\n};\n\n// A wrapper class whose instances are generated by keydown user input events\nclass GameAction {\n  constructor(type, props) {\n    this.type = type;\n    this.props = props;\n  }\n}\n\n// A class whose instance acts as a UseState for canvas to listen and hold onto keystrokes, to be consumed by a GameState on its update.\nclass GameController {\n  constructor() {\n    this.actionQueue = [];\n  }\n\n  // TODO: Right now the default keyDown event doesn't immediately repeat keys held down. Change the implementation\n  // such that a keyDown event adds to a keyset and a corresponding keyUp event removes from the keyset, and replace consumeAction\n  // with a function that simply returns the mapped actions from the.\n\n  // We should have two types of controls: holdable keys which follow the rule above, and single-press keys which already work as\n  // intended with keyDown. Holdable keys include WASD movement, and single-press keys include SPACE and QE for placing/rotation.\n  handleKeyDown(key) {\n    var action = null;\n    if (key == \"w\") {\n      action = new GameAction(ActionType.MOVE, {\n        angle: 1\n      });\n    } else if (key == \"a\") {\n      action = new GameAction(ActionType.MOVE, {\n        angle: 2\n      });\n    } else if (key == \"s\") {\n      action = new GameAction(ActionType.MOVE, {\n        angle: 3\n      });\n    } else if (key == \"d\") {\n      action = new GameAction(ActionType.MOVE, {\n        angle: 0\n      });\n\n      // TODO: Change handleKeypress to take in the whole event so keyCode can be invoked for arrow keys.\n    } else if (key == \"q\") {\n      action = new GameAction(ActionType.ROTATE, {\n        angle: 1\n      });\n    } else if (key == \"e\") {\n      action = new GameAction(ActionType.ROTATE, {\n        angle: -1\n      });\n    } else if (key == \" \") {\n      action = new GameAction(ActionType.PLACE, {});\n    }\n    if (action != null) {\n      this.actionQueue.push(action);\n    }\n    return this;\n  }\n\n  // Consume the last action registered in the queue.\n  // TODO: As above, \n  consumeAction() {\n    return this.actionQueue.shift();\n  }\n}\nexport default GameController;","map":{"version":3,"names":["ActionType","MOVE","ROTATE","PLACE","GameAction","constructor","type","props","GameController","actionQueue","handleKeyDown","key","action","angle","push","consumeAction","shift"],"sources":["/Users/joeyzhu/code/visuals/pentaquad/src/components/game/GameController.js"],"sourcesContent":["const ActionType = {\n    MOVE: 0,\n    ROTATE: 1,\n    PLACE: 2,\n}\n\n// A wrapper class whose instances are generated by keydown user input events\nclass GameAction {\n    constructor(type, props) {\n        this.type = type\n        this.props = props\n    }\n}\n\n// A class whose instance acts as a UseState for canvas to listen and hold onto keystrokes, to be consumed by a GameState on its update.\nclass GameController {\n    constructor() {\n        this.actionQueue = [];\n    }\n\n    // TODO: Right now the default keyDown event doesn't immediately repeat keys held down. Change the implementation\n    // such that a keyDown event adds to a keyset and a corresponding keyUp event removes from the keyset, and replace consumeAction\n    // with a function that simply returns the mapped actions from the.\n    \n    // We should have two types of controls: holdable keys which follow the rule above, and single-press keys which already work as\n    // intended with keyDown. Holdable keys include WASD movement, and single-press keys include SPACE and QE for placing/rotation.\n    handleKeyDown(key) {\n        var action = null;\n        if (key == \"w\") {\n            action = new GameAction(ActionType.MOVE, {angle: 1})\n        } else if (key == \"a\") {\n            action = new GameAction(ActionType.MOVE, {angle: 2})\n        } else if (key == \"s\") {\n            action = new GameAction(ActionType.MOVE, {angle: 3})\n        } else if (key == \"d\") {\n            action = new GameAction(ActionType.MOVE, {angle: 0})\n        \n        // TODO: Change handleKeypress to take in the whole event so keyCode can be invoked for arrow keys.\n        } else if (key == \"q\") {\n            action = new GameAction(ActionType.ROTATE, {angle: 1})\n        } else if (key == \"e\") {\n            action = new GameAction(ActionType.ROTATE, {angle: -1})\n\n        } else if (key == \" \") {\n            action = new GameAction(ActionType.PLACE, {})\n        }\n        if (action != null) {\n            this.actionQueue.push(action)\n        }\n        return this;\n    }\n\n    // Consume the last action registered in the queue.\n    // TODO: As above, \n    consumeAction() {         \n        return this.actionQueue.shift()\n    }\n}\n\nexport default GameController;"],"mappings":"AAAA,MAAMA,UAAU,GAAG;EACfC,IAAI,EAAE,CAAC;EACPC,MAAM,EAAE,CAAC;EACTC,KAAK,EAAE;AACX,CAAC;;AAED;AACA,MAAMC,UAAU,CAAC;EACbC,WAAWA,CAACC,IAAI,EAAEC,KAAK,EAAE;IACrB,IAAI,CAACD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;EACtB;AACJ;;AAEA;AACA,MAAMC,cAAc,CAAC;EACjBH,WAAWA,CAAA,EAAG;IACV,IAAI,CAACI,WAAW,GAAG,EAAE;EACzB;;EAEA;EACA;EACA;;EAEA;EACA;EACAC,aAAaA,CAACC,GAAG,EAAE;IACf,IAAIC,MAAM,GAAG,IAAI;IACjB,IAAID,GAAG,IAAI,GAAG,EAAE;MACZC,MAAM,GAAG,IAAIR,UAAU,CAACJ,UAAU,CAACC,IAAI,EAAE;QAACY,KAAK,EAAE;MAAC,CAAC,CAAC;IACxD,CAAC,MAAM,IAAIF,GAAG,IAAI,GAAG,EAAE;MACnBC,MAAM,GAAG,IAAIR,UAAU,CAACJ,UAAU,CAACC,IAAI,EAAE;QAACY,KAAK,EAAE;MAAC,CAAC,CAAC;IACxD,CAAC,MAAM,IAAIF,GAAG,IAAI,GAAG,EAAE;MACnBC,MAAM,GAAG,IAAIR,UAAU,CAACJ,UAAU,CAACC,IAAI,EAAE;QAACY,KAAK,EAAE;MAAC,CAAC,CAAC;IACxD,CAAC,MAAM,IAAIF,GAAG,IAAI,GAAG,EAAE;MACnBC,MAAM,GAAG,IAAIR,UAAU,CAACJ,UAAU,CAACC,IAAI,EAAE;QAACY,KAAK,EAAE;MAAC,CAAC,CAAC;;MAExD;IACA,CAAC,MAAM,IAAIF,GAAG,IAAI,GAAG,EAAE;MACnBC,MAAM,GAAG,IAAIR,UAAU,CAACJ,UAAU,CAACE,MAAM,EAAE;QAACW,KAAK,EAAE;MAAC,CAAC,CAAC;IAC1D,CAAC,MAAM,IAAIF,GAAG,IAAI,GAAG,EAAE;MACnBC,MAAM,GAAG,IAAIR,UAAU,CAACJ,UAAU,CAACE,MAAM,EAAE;QAACW,KAAK,EAAE,CAAC;MAAC,CAAC,CAAC;IAE3D,CAAC,MAAM,IAAIF,GAAG,IAAI,GAAG,EAAE;MACnBC,MAAM,GAAG,IAAIR,UAAU,CAACJ,UAAU,CAACG,KAAK,EAAE,CAAC,CAAC,CAAC;IACjD;IACA,IAAIS,MAAM,IAAI,IAAI,EAAE;MAChB,IAAI,CAACH,WAAW,CAACK,IAAI,CAACF,MAAM,CAAC;IACjC;IACA,OAAO,IAAI;EACf;;EAEA;EACA;EACAG,aAAaA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACN,WAAW,CAACO,KAAK,EAAE;EACnC;AACJ;AAEA,eAAeR,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}