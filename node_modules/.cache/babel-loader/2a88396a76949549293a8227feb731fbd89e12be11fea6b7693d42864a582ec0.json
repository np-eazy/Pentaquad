{"ast":null,"code":"import Direction from \"./Direction\";\nimport Cell from \"./Cell\";\nimport Piece from \"./Piece\";\nimport { randint, Gravity } from \"./Utils\";\nimport { ActionType } from \"./GameAction\";\nfunction getPID(x, y, groupSize) {\n  return x * groupSize + y;\n}\nconst PIECE_SIZE = 5;\nconst SPAWN_OFFSET = 2;\nconst BOUNDARY_MARGIN = 4;\nconst CoreState = class {\n  constructor(props) {\n    this.timer = 0;\n    this.emptyValue = () => new Cell(0, {});\n    this.board = [...Array(props.boardSize)].map(e => Array(props.boardSize).fill(this.emptyValue()));\n    this.boardSize = props.boardSize;\n    this.pidSize = (props.boardSize + SPAWN_OFFSET * 2) * 2;\n    this.gravity = new Direction(Gravity.DOWN);\n    this.placeBlock = true;\n    this.currPiece = null;\n    this.controller = props.controller;\n\n    // Create 4 different sets to check if a boundary has been hit\n    var [xSize, ySize] = [props.boardSize, props.boardSize];\n    var pid;\n    this.boundarySets = [];\n    var boundarySet = new Map();\n    for (var y = -BOUNDARY_MARGIN; y < ySize + BOUNDARY_MARGIN; y++) {\n      pid = getPID(xSize, y, this.pidSize);\n      boundarySet.set(pid, [xSize, y]);\n    }\n    this.boundarySets.push(boundarySet);\n    boundarySet = new Map();\n    for (var x = -BOUNDARY_MARGIN; x < xSize + BOUNDARY_MARGIN; x++) {\n      pid = getPID(x, -1, this.pidSize);\n      boundarySet.set(pid, [x, -1]);\n    }\n    this.boundarySets.push(boundarySet);\n    boundarySet = new Map();\n    for (var y = -BOUNDARY_MARGIN; y < ySize + BOUNDARY_MARGIN; y++) {\n      pid = getPID(-1, y, this.pidSize);\n      boundarySet.set(pid, [-1, y]);\n    }\n    this.boundarySets.push(boundarySet);\n    boundarySet = new Map();\n    for (var x = -BOUNDARY_MARGIN; x < xSize + BOUNDARY_MARGIN; x++) {\n      pid = getPID(x, ySize, this.pidSize);\n      boundarySet.set(pid, [x, ySize]);\n    }\n    this.boundarySets.push(boundarySet);\n  }\n  update(actions) {\n    if (this.placeBlock) {\n      this.placeBlock = false;\n      var [x, y] = [0, 0];\n\n      // Place the current piece\n      if (this.currPiece != null) {\n        for (const cell of this.currPiece.cells) {\n          [x, y] = [cell[1][0] + this.currPiece.cx, cell[1][1] + this.currPiece.cy];\n          if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize) {\n            this.board[y][x] = this.currPiece.createCell();\n          }\n        }\n      }\n\n      // Set the position and gravity with which to create a new piece\n      this.gravity.turnLeft(1);\n      var r = randint(-SPAWN_OFFSET, this.boardSize + SPAWN_OFFSET);\n      if (this.gravity.angle == Gravity.RIGHT) {\n        [x, y] = [-SPAWN_OFFSET, r];\n      } else if (this.gravity.angle == Gravity.UP) {\n        [x, y] = [r, SPAWN_OFFSET + this.boardSize];\n      } else if (this.gravity.angle == Gravity.LEFT) {\n        [x, y] = [SPAWN_OFFSET + this.boardSize, r];\n      } else if (this.gravity.angle == Gravity.DOWN) {\n        [x, y] = [r, -SPAWN_OFFSET];\n      }\n      this.currPiece = new Piece({\n        center_x: x,\n        center_y: y,\n        angle: this.gravity.angle,\n        pieceSize: PIECE_SIZE,\n        pidSize: this.pidSize\n      });\n\n      // Check for filled lines\n      var angle = this.currPiece.dxn.angle;\n      if (angle % 2 == 0) {\n        for (var x = 0; x < this.boardSize; x++) {\n          var count = 0;\n          for (var y = 0; y < this.boardSize; y++) {\n            if (this.board[y][x].type > 0) {\n              count += 1;\n            }\n          }\n          // Horizontally shift the left or the right of the cleared line\n          if (count >= this.boardSize / 2) {\n            if (angle % 4 == 2) {\n              for (var j = 0; j < x; j++) {\n                i = x - j - 1;\n                for (var y_ = 0; y_ < this.boardSize; y_++) {\n                  this.board[y_][i + 1] = this.board[y_][i];\n                }\n              }\n              for (var y_ = 0; y_ < this.boardSize; y_++) {\n                this.board[y_][this.boardSize - 1] = new Cell(0, {});\n              }\n            } else {\n              for (var i = x + 1; i < this.boardSize; i++) {\n                for (var y_ = 0; y_ < this.boardSize; y_++) {\n                  this.board[y_][i - 1] = this.board[y_][i];\n                }\n              }\n              for (var y_ = 0; y_ < this.boardSize; y_++) {\n                this.board[y_][0] = new Cell(0, {});\n              }\n            }\n          }\n        }\n      } else {\n        for (var y = 0; y < this.boardSize; y++) {\n          var count = 0;\n          for (var x = 0; x < this.boardSize; x++) {\n            if (this.board[y][x].type > 0) {\n              count += 1;\n            }\n          }\n          // Horizontally shift the left or the right of the cleared line\n          if (count >= this.boardSize / 2) {\n            if (angle % 4 == 1) {\n              for (var j = 0; j < y; j++) {\n                i = y - j - 1;\n                for (var x_ = 0; x_ < this.boardSize; x_++) {\n                  this.board[i + 1][x_] = this.board[i][x_];\n                }\n              }\n              for (var x_ = 0; x_ < this.boardSize; x_++) {\n                this.board[0][x_] = new Cell(0, {});\n              }\n            } else {\n              for (var i = y + 1; j < this.boardSize; i++) {\n                for (var x_ = 0; x_ < this.boardSize; x_++) {\n                  this.board[i - 1][x_] = this.board[i][x_];\n                }\n              }\n              for (var x_ = 0; x_ < this.boardSize; x_++) {\n                this.board[this.boardSize - 1][x_] = new Cell(0, {});\n              }\n            }\n            break;\n          }\n        }\n      }\n    } else {\n      if (this.currPiece) {\n        this.currPiece.idleMove();\n        if (this.currPiece.checkCollision(this.currPiece.dxn.angle, this.board, this.boundarySets)) {\n          this.placeBlock = true;\n        } else {\n          if (this.controller && !this.placeBlock) {\n            var action = this.controller.consumeAction();\n            if (action) {\n              this.executeAction(action);\n            }\n          }\n        }\n      }\n    }\n    return this;\n  }\n\n  // TODO: Call this.currPiece.activeMove and check for the collision in both idle and active directions\n  executeAction(action) {\n    if (action.type == ActionType.MOVE) {\n      if (this.currPiece.checkCollision(action.props.angle, this.board, this.boundarySets)) {\n        this.placeBlock = true;\n      } else {\n        this.currPiece.activeMove(action.props.angle);\n        if (this.currPiece.checkCollision(this.currPiece.dxn.angle, this.board, this.boundarySets)) {\n          this.placeBlock = true;\n        }\n      }\n    } else if (action.type == ActionType.PLACE) {\n      this.placeBlock = true;\n    }\n    return this;\n  }\n};\nexport default CoreState;","map":{"version":3,"names":["Direction","Cell","Piece","randint","Gravity","ActionType","getPID","x","y","groupSize","PIECE_SIZE","SPAWN_OFFSET","BOUNDARY_MARGIN","CoreState","constructor","props","timer","emptyValue","board","Array","boardSize","map","e","fill","pidSize","gravity","DOWN","placeBlock","currPiece","controller","xSize","ySize","pid","boundarySets","boundarySet","Map","set","push","update","actions","cell","cells","cx","cy","createCell","turnLeft","r","angle","RIGHT","UP","LEFT","center_x","center_y","pieceSize","dxn","count","type","j","i","y_","x_","idleMove","checkCollision","action","consumeAction","executeAction","MOVE","activeMove","PLACE"],"sources":["/Users/joeyzhu/code/visuals/pentaquad/src/components/game/coreState/CoreState.js"],"sourcesContent":["import Direction from \"./Direction\"\nimport Cell from \"./Cell\"\nimport Piece from \"./Piece\"\nimport { randint, Gravity } from \"./Utils\"\nimport { ActionType } from \"./GameAction\"\n\n\n\nfunction getPID(x, y, groupSize) {\n    return x * groupSize + y;\n}\n\nconst PIECE_SIZE = 5;\nconst SPAWN_OFFSET = 2;\nconst BOUNDARY_MARGIN = 4;\n\n\nconst CoreState = class {\n    constructor (props) {\n        this.timer = 0;\n        this.emptyValue = () => new Cell(0, {}); \n        this.board = [...Array(props.boardSize)].map(e => Array(props.boardSize).fill(this.emptyValue()));\n        this.boardSize = props.boardSize;\n        this.pidSize = (props.boardSize + SPAWN_OFFSET * 2) * 2;\n        this.gravity = new Direction(Gravity.DOWN);\n        this.placeBlock = true;\n        this.currPiece = null;\n        this.controller = props.controller;\n\n        // Create 4 different sets to check if a boundary has been hit\n        var [xSize, ySize] = [props.boardSize, props.boardSize]\n        var pid;\n        this.boundarySets = [];\n        var boundarySet = new Map()\n        for (var y = -BOUNDARY_MARGIN; y < ySize + BOUNDARY_MARGIN; y++) {\n            pid = getPID(xSize, y, this.pidSize);\n            boundarySet.set(pid, [xSize, y])\n        }\n        this.boundarySets.push(boundarySet);\n\n        boundarySet = new Map()\n        for (var x = -BOUNDARY_MARGIN; x < xSize + BOUNDARY_MARGIN; x++) {\n            pid = getPID(x, -1, this.pidSize);\n            boundarySet.set(pid, [x, -1])\n        }\n        this.boundarySets.push(boundarySet);\n\n        boundarySet = new Map()\n        for (var y = -BOUNDARY_MARGIN; y < ySize + BOUNDARY_MARGIN; y++) {\n            pid = getPID(-1, y, this.pidSize);\n            boundarySet.set(pid, [-1, y])\n        }\n        this.boundarySets.push(boundarySet);\n\n        boundarySet = new Map()\n        for (var x = -BOUNDARY_MARGIN; x < xSize + BOUNDARY_MARGIN; x++) {\n            pid = getPID(x, ySize, this.pidSize);\n            boundarySet.set(pid, [x, ySize])\n        }\n        this.boundarySets.push(boundarySet);\n    }\n\n    update(actions) {\n        if (this.placeBlock) {\n            this.placeBlock = false;\n            var [x, y] = [0, 0]\n\n            // Place the current piece\n            if (this.currPiece != null) {\n                for (const cell of this.currPiece.cells) {\n                    [x, y] = [cell[1][0] + this.currPiece.cx, cell[1][1] + this.currPiece.cy]\n                    if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize) {\n                        this.board[y][x] = this.currPiece.createCell()\n                    }\n                }\n            }\n\n            // Set the position and gravity with which to create a new piece\n            this.gravity.turnLeft(1);\n            var r = randint(-SPAWN_OFFSET, this.boardSize + SPAWN_OFFSET)\n            if (this.gravity.angle == Gravity.RIGHT) {\n                [x, y] = [-SPAWN_OFFSET, r]\n            } else if (this.gravity.angle == Gravity.UP) {\n                [x, y] = [r, SPAWN_OFFSET + this.boardSize]\n            } else if (this.gravity.angle == Gravity.LEFT) {\n                [x, y] = [SPAWN_OFFSET + this.boardSize, r]\n            } else if (this.gravity.angle == Gravity.DOWN) {\n                [x, y] = [r, -SPAWN_OFFSET]\n            }\n\n            this.currPiece = new Piece({\n                center_x: x,\n                center_y: y,\n                angle: this.gravity.angle,\n                pieceSize: PIECE_SIZE,\n                pidSize: this.pidSize,\n            })\n\n            // Check for filled lines\n            var angle = this.currPiece.dxn.angle\n            if (angle % 2 == 0) {\n                for (var x = 0; x < this.boardSize; x++) {\n                    var count = 0;\n                    for (var y = 0; y < this.boardSize; y++) {\n                        if (this.board[y][x].type > 0) {\n                            count += 1;\n                        }\n                    }\n                    // Horizontally shift the left or the right of the cleared line\n                    if (count >= this.boardSize / 2) {\n                        if (angle % 4 == 2) {\n                            for (var j = 0; j < x; j++) {\n                                i = x - j - 1\n                                for (var y_ = 0; y_ < this.boardSize; y_++) {\n                                    this.board[y_][i + 1] = this.board[y_][i]\n                                }\n                            }\n                            for (var y_ = 0; y_ < this.boardSize; y_++) {\n                                this.board[y_][this.boardSize - 1] = new Cell(0, {})\n                            }\n                        } else {\n                            for (var i = x + 1; i < this.boardSize; i++) {\n                                for (var y_ = 0; y_ < this.boardSize; y_++) {\n                                    this.board[y_][i - 1] = this.board[y_][i]\n                                }\n                            }\n                            for (var y_ = 0; y_ < this.boardSize; y_++) {\n                                this.board[y_][0] = new Cell(0, {})\n                            }\n                        }\n                    }\n                }\n            } else {\n                for (var y = 0; y < this.boardSize; y++) {\n                    var count = 0;\n                    for (var x = 0; x < this.boardSize; x++) {\n                        if (this.board[y][x].type > 0) {\n                            count += 1;\n                        }\n                    }\n                    // Horizontally shift the left or the right of the cleared line\n                    if (count >= this.boardSize / 2) {\n                        if (angle % 4 == 1) {\n                            for (var j = 0; j < y; j++) {\n                                i = y - j - 1\n                                for (var x_ = 0; x_ < this.boardSize; x_++) {\n                                    this.board[i + 1][x_] = this.board[i][x_]\n                                }\n                            }\n                            for (var x_ = 0; x_ < this.boardSize; x_++) {\n                                this.board[0][x_] = new Cell(0, {})\n                            }\n                        } else {\n                            for (var i = y + 1; j < this.boardSize; i++) {\n                                for (var x_ = 0; x_ < this.boardSize; x_++) {\n                                    this.board[i - 1][x_] = this.board[i][x_]\n                                }\n                            }\n                            for (var x_ = 0; x_ < this.boardSize; x_++) {\n                                this.board[this.boardSize - 1][x_] = new Cell(0, {})\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n        } else {\n            if (this.currPiece) {\n                this.currPiece.idleMove()\n                if (this.currPiece.checkCollision(this.currPiece.dxn.angle, this.board, this.boundarySets)) {\n                    this.placeBlock = true\n                } else {\n                    if (this.controller && !this.placeBlock) {\n                        var action = this.controller.consumeAction()\n                        if (action) {\n                            this.executeAction(action)\n                        }\n                    }\n                }\n            }\n        }\n        return this;\n    }\n\n    // TODO: Call this.currPiece.activeMove and check for the collision in both idle and active directions\n    executeAction(action) {\n        if (action.type == ActionType.MOVE) {\n            if (this.currPiece.checkCollision(action.props.angle, this.board, this.boundarySets)) {\n                this.placeBlock = true\n            } else {\n                this.currPiece.activeMove(action.props.angle)\n                if (this.currPiece.checkCollision(this.currPiece.dxn.angle, this.board, this.boundarySets) ) {\n                    this.placeBlock = true\n                }\n            }\n        } else if (action.type == ActionType.PLACE) {\n            this.placeBlock = true\n        }\n        return this;\n    }\n}\n\nexport default CoreState;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}