{"ast":null,"code":"import Cell from \"./Cell\";\nimport { randint, getPID, Direction, DXN, NULL_DXN } from \"./Utils\";\nimport { Color } from \"../graphics/Colors\";\n\n// 5-long piece preset\nconst I_PIECE = [[0, -2], [0, -1], [0, 0], [0, 1], [0, 2]];\n\n// 4-long piece presets\nconst L1_PIECE = [[0, -2], [0, -1], [0, 0], [0, 1], [1, 1]];\nconst S1_PIECE = [[0, -2], [0, -1], [0, 0], [1, 0], [1, 1]];\nconst T1_PIECE = [[0, -2], [0, -1], [0, 0], [0, 1], [1, 0]];\n\n// 3-long piece presets\nconst L2_PIECE = [[-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];\nconst S2_PIECE = [[-1, -1], [0, -1], [0, 0], [0, 1], [1, 1]];\nconst T2_PIECE = [[1, 1], [0, 1], [0, 0], [0, -1], [-1, 1]];\nconst X_PIECE = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]];\nconst F_PIECE = [[0, 0], [0, 1], [1, 1], [0, -1], [-1, 0]];\nconst U_PIECE = [[1, -1], [0, -1], [0, 0], [0, 1], [1, 1]];\nconst B_PIECE = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]];\n\n// Other pieces\nconst W_PIECE = [[-1, 1], [0, 1], [0, 0], [1, 0], [1, -1]];\nconst PRESETS = [I_PIECE, L1_PIECE, S1_PIECE, T1_PIECE, L2_PIECE, S2_PIECE, T2_PIECE, X_PIECE, F_PIECE, U_PIECE, B_PIECE, W_PIECE];\n\n// A single piece in the game, which can move in different directions and detect collisions\n// based on which direction is moving.\nclass Piece {\n  constructor(_ref) {\n    let {\n      center_x,\n      center_y,\n      angle,\n      pieceSize,\n      pidSize\n    } = _ref;\n    [this.cx, this.cy, this.dxn] = [center_x, center_y, new Direction(angle)];\n    this.pidSize = pidSize;\n\n    // Create some arrangement of 5 contiguous cells.\n    // TODO: It would be faster/easier to pull from a set of all possible existing cells\n    this.cells = new Map();\n    var preset = PRESETS[randint(0, PRESETS.length)];\n    for (var [x, y] of preset) {\n      this.cells.set(getPID(x, y, pidSize), [x, y]);\n    }\n    this.rotate(randint(0, 4));\n    if (randint(0, 2) == 1) {\n      this.flip();\n    }\n\n    // Set this piece's color based on its initial direction; there will be more\n    // room to customize this.\n    if (angle % 4 == DXN.RIGHT) {\n      this.color = new Color({\n        red: 225,\n        green: 0,\n        blue: 105\n      });\n    } else if (angle % 4 == DXN.UP) {\n      this.color = new Color({\n        red: 255,\n        green: 125,\n        blue: 0\n      });\n    } else if (angle % 4 == DXN.LEFT) {\n      this.color = new Color({\n        red: 0,\n        green: 235,\n        blue: 175\n      });\n    } else if (angle % 4 == DXN.DOWN) {\n      this.color = new Color({\n        red: 0,\n        green: 200,\n        blue: 235\n      });\n    }\n  }\n\n  // Pass in a list of [x, y] pairs to add to the Cells map.\n  setCells() {}\n\n  // The function to fill the coreState with cells corresponding to this Piece; this will\n  // be used for cases like the render script accessing the color in the parents\n  createCell() {\n    var cell = new Cell(1, {\n      parent: this\n    });\n    return cell;\n  }\n\n  // Return whether or not the block has a collision with this angle.\n  // Null angle option is for rotation collision check, only to make sure that the piece\n  // doesn't rotate into any overlaps with filled cells.\n  checkCollision(angle, board, boundarySets) {\n    var [xSize, ySize] = [board.length, board[0].length];\n    var collisionDxn = angle == null ? {\n      dx: 0,\n      dy: 0\n    } : new Direction(angle);\n    var boundarySet = angle == null ? new Set() : boundarySets[angle];\n    var collision = false;\n\n    // Check for a boundary collision\n    this.cells.forEach(val => {\n      var globalPid = getPID(val[0] + this.cx + collisionDxn.dx, val[1] + this.cy + collisionDxn.dy, this.pidSize);\n      if (!collision && boundarySet.has(globalPid)) {\n        collision = true;\n      }\n    });\n    if (collision == true) {\n      return true;\n    }\n\n    // Check for a board collision\n    for (var y = 0; y < ySize; y++) {\n      for (var x = 0; x < xSize; x++) {\n        if (board[y][x].type > 0) {\n          // x, y generate global PIDs\n          // Subtract cx and cy from PIDs to localize\n          var globalPid = getPID(x - this.cx - collisionDxn.dx, y - this.cy - collisionDxn.dy, this.pidSize);\n          if (!collision && this.cells.has(globalPid)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Move this piece based on a given x and y direction and recheck its appropriate hitbox\n  activeMove(angle) {\n    var adxn = new Direction(angle);\n    this.cx += adxn.dx;\n    this.cy += adxn.dy;\n  }\n\n  // Move this piece based on its gravity and recheck its appropriate hitbox.\n  idleMove() {\n    this.cx += this.dxn.dx;\n    this.cy += this.dxn.dy;\n  }\n  rotate(angle) {\n    if (angle < 0) {\n      this.signedRotate(angle, -1);\n    } else {\n      this.signedRotate(angle, 1);\n    }\n  }\n  signedRotate(turns, sign) {\n    for (var t = 0; t < sign * turns % 4; t++) {\n      var newCells = new Map();\n      this.cells.forEach(val => {\n        var [newX, newY] = [val[1] * sign, -val[0] * sign];\n        var pid = getPID(newX, newY, this.pidSize);\n        newCells.set(pid, [newX, newY]);\n      });\n      this.cells = newCells;\n    }\n  }\n  flip() {\n    var newCells = new Map();\n    this.cells.forEach(val => {\n      var [newX, newY] = [val[0], -val[1]];\n      var pid = getPID(newX, newY, this.pidSize);\n      newCells.set(pid, [newX, newY]);\n    });\n    this.cells = newCells;\n  }\n}\nexport default Piece;","map":{"version":3,"names":["Cell","randint","getPID","Direction","DXN","NULL_DXN","Color","I_PIECE","L1_PIECE","S1_PIECE","T1_PIECE","L2_PIECE","S2_PIECE","T2_PIECE","X_PIECE","F_PIECE","U_PIECE","B_PIECE","W_PIECE","PRESETS","Piece","constructor","_ref","center_x","center_y","angle","pieceSize","pidSize","cx","cy","dxn","cells","Map","preset","length","x","y","set","rotate","flip","RIGHT","color","red","green","blue","UP","LEFT","DOWN","setCells","createCell","cell","parent","checkCollision","board","boundarySets","xSize","ySize","collisionDxn","dx","dy","boundarySet","Set","collision","forEach","val","globalPid","has","type","activeMove","adxn","idleMove","signedRotate","turns","sign","t","newCells","newX","newY","pid"],"sources":["/Users/joeyzhu/code/Pentaquad/src/components/game/coreState/Piece.js"],"sourcesContent":["import Cell from \"./Cell\";\nimport { randint, getPID, Direction, DXN, NULL_DXN } from \"./Utils\";\nimport { Color } from \"../graphics/Colors\";\n\n\n// 5-long piece preset\nconst I_PIECE = [[0, -2], [0, -1], [0, 0], [0, 1], [0, 2]]\n\n// 4-long piece presets\nconst L1_PIECE = [[0, -2], [0, -1], [0, 0], [0, 1], [1, 1]]\nconst S1_PIECE = [[0, -2], [0, -1], [0, 0], [1, 0], [1, 1]]\nconst T1_PIECE = [[0, -2], [0, -1], [0, 0], [0, 1], [1, 0]]\n\n// 3-long piece presets\nconst L2_PIECE = [[-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]]\nconst S2_PIECE = [[-1, -1], [0, -1], [0, 0], [0, 1], [1, 1]]\nconst T2_PIECE = [[1, 1], [0, 1], [0, 0], [0, -1], [-1, 1]]\nconst X_PIECE = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\nconst F_PIECE = [[0, 0], [0, 1], [1, 1], [0, -1], [-1, 0]]\nconst U_PIECE = [[1, -1], [0, -1], [0, 0], [0, 1], [1, 1]]\nconst B_PIECE = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]]\n\n// Other pieces\nconst W_PIECE = [[-1, 1], [0, 1], [0, 0], [1, 0], [1, -1]]\n\nconst PRESETS = [\n    I_PIECE, \n    L1_PIECE, S1_PIECE, T1_PIECE, \n    L2_PIECE, S2_PIECE, T2_PIECE, X_PIECE, F_PIECE, U_PIECE, B_PIECE, \n    W_PIECE\n]\n\n\n// A single piece in the game, which can move in different directions and detect collisions\n// based on which direction is moving.\nclass Piece {\n    constructor({\n        center_x, \n        center_y, \n        angle, \n        pieceSize, \n        pidSize\n    }) {\n        [this.cx, this.cy, this.dxn] = [center_x, center_y, new Direction(angle)];\n        this.pidSize = pidSize;\n\n        // Create some arrangement of 5 contiguous cells.\n        // TODO: It would be faster/easier to pull from a set of all possible existing cells\n        this.cells = new Map()\n        var preset = PRESETS[randint(0, PRESETS.length)]\n        for (var [x, y] of preset) {\n            this.cells.set(getPID(x, y, pidSize), [x, y])\n        }\n        this.rotate(randint(0, 4))\n        if (randint(0, 2) == 1) {\n            this.flip()\n        }\n\n        // Set this piece's color based on its initial direction; there will be more\n        // room to customize this.\n        if (angle % 4 == DXN.RIGHT) {\n            this.color = new Color({ red: 225, green: 0, blue: 105})\n        } else if (angle % 4 == DXN.UP) {\n            this.color = new Color({ red: 255, green: 125, blue: 0})\n        } else if (angle % 4 == DXN.LEFT) {\n            this.color = new Color({ red: 0, green: 235, blue: 175})\n        } else if (angle % 4 == DXN.DOWN) {\n            this.color = new Color({ red: 0, green: 200, blue: 235})\n        }  \n    }\n\n    // Pass in a list of [x, y] pairs to add to the Cells map.\n    setCells() {\n\n    }\n\n    // The function to fill the coreState with cells corresponding to this Piece; this will\n    // be used for cases like the render script accessing the color in the parents\n    createCell() {\n        var cell = new Cell(1, {parent: this});\n        return cell;\n    }\n\n    // Return whether or not the block has a collision with this angle.\n    // Null angle option is for rotation collision check, only to make sure that the piece\n    // doesn't rotate into any overlaps with filled cells.\n    checkCollision(angle, board, boundarySets) {\n        var [xSize, ySize] = [board.length, board[0].length];\n\n        var collisionDxn = angle == null ? { dx: 0, dy: 0 } : new Direction(angle)\n        var boundarySet = angle == null ? new Set() : boundarySets[angle];\n        var collision = false;\n\n        // Check for a boundary collision\n        this.cells.forEach((val) => {\n            var globalPid = getPID(\n                val[0] + this.cx + collisionDxn.dx, \n                val[1] + this.cy + collisionDxn.dy, \n                this.pidSize)\n            if (!collision && boundarySet.has(globalPid)) {\n                collision = true;\n            }\n        })\n        if (collision == true) {\n            return true;\n        }\n\n        // Check for a board collision\n        for (var y = 0; y < ySize; y++) {\n            for (var x = 0; x < xSize; x++) {\n                if (board[y][x].type > 0) {\n                    // x, y generate global PIDs\n                    // Subtract cx and cy from PIDs to localize\n                    var globalPid = getPID(\n                        x - this.cx - collisionDxn.dx, \n                        y - this.cy - collisionDxn.dy, \n                        this.pidSize)\n                    if (!collision && this.cells.has(globalPid)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    // Move this piece based on a given x and y direction and recheck its appropriate hitbox\n    activeMove(angle) {\n        var adxn = new Direction(angle);\n        this.cx += adxn.dx;\n        this.cy += adxn.dy;\n    }\n\n    // Move this piece based on its gravity and recheck its appropriate hitbox.\n    idleMove() {\n        this.cx += this.dxn.dx;\n        this.cy += this.dxn.dy;\n    }\n\n    rotate(angle) {\n        if (angle < 0) {\n            this.signedRotate(angle, -1)\n        } else {\n            this.signedRotate(angle, 1)\n        }\n    }\n\n    signedRotate(turns, sign) {\n        for (var t = 0; t < (sign * turns) % 4; t++) {\n            var newCells = new Map()\n            this.cells.forEach((val) => {\n                var [newX, newY] = [val[1] * sign, -val[0] * sign]\n                var pid = getPID(newX, newY, this.pidSize)\n                newCells.set(pid, [newX, newY])\n            })\n            this.cells = newCells\n        }\n    }\n\n    flip() {\n        var newCells = new Map()\n        this.cells.forEach((val) => {\n            var [newX, newY] = [val[0], -val[1]]\n            var pid = getPID(newX, newY, this.pidSize)\n            newCells.set(pid, [newX, newY])\n        })\n        this.cells = newCells\n    }\n}\n\nexport default Piece;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}