{"ast":null,"code":"import Cell from \"./Cell\";\nimport Piece from \"./Piece\";\nimport TargetBlock from \"./TargetBlock\";\nimport { randint, getPID, Direction, DXN } from \"./Utils\";\nimport { ActionType } from \"./GameAction\";\n\n// Number of cells in each piece.\nconst PIECE_SIZE = 5;\n// The distance from the boundary that each piece \nconst SPAWN_OFFSET = -3;\n// Extend edge boundaries a bit further out of the grid to make sure\n// pieces spawning on the edge can still hit the ground.\nconst BOUNDARY_MARGIN = 4;\n// The number of ticks contact must take place in order to place a piece.\nconst COLLISION_TIME_LIMIT = 20;\n\n// The most essential level of state in the game. Each update() call either\n// moves an existing block, or places it and creates a new block after shifting\n// gravity. \n\nconst CoreState = class {\n  constructor(props) {\n    // The GameState's main controller\n    this.controller = null;\n    // A timer that increments once each update; updates should only be called from a higher-level state which is allowed to control the flow of \"core\" tempo.\n    this.timer = 0;\n    // The dimension of the square board on which this game takes place.\n    this.boardSize = props.boardSize;\n    // The default \"empty\" value of this grid: a type-0 Cell with no props\n    this.emptyValue = () => new Cell(0, {});\n    // The main board on which everything happens\n    this.board = [...Array(props.boardSize)].map(e => Array(props.boardSize).fill(this.emptyValue()));\n    // All sets of (x, y) pairs checking each other for collisions will have a unique PID dependent on a 3rd parameter describing the max size of the PID group, in order for uniqueness to work.\n    this.pidSize = (props.boardSize + BOUNDARY_MARGIN * 2) * 2;\n    // The direction in which the piece moves, and in which the board moves after a line is cleared.\n    this.gravity = new Direction(DXN.LEFT);\n    // Flag for placing a block\n    this.placeBlock = true;\n    // The GameState's current unplaced piece\n    this.currPiece = null;\n    // The GameState's roster of target blocks\n    this.targetBlocks = [];\n    // Keep track of how long this piece is in contact in its falling direction\n    this.collisionTimer = 0;\n    // GameOver flag\n    this.isGameOver = false;\n\n    // Create 4 different sets to check if a boundary has been hit\n    var [xSize, ySize] = [props.boardSize, props.boardSize];\n    var pid;\n    this.boundarySets = [];\n    for (var i = 0; i < 4; i++) {\n      this.boundarySets.push(new Map());\n    }\n    for (var i = -BOUNDARY_MARGIN; i < ySize + BOUNDARY_MARGIN; i++) {\n      pid = getPID(xSize, i, this.pidSize);\n      this.boundarySets[DXN.RIGHT].set(pid, [xSize, i]);\n      pid = getPID(i, -1, this.pidSize);\n      this.boundarySets[DXN.UP].set(pid, [i, -1]);\n      pid = getPID(-1, i, this.pidSize);\n      this.boundarySets[DXN.LEFT].set(pid, [-1, i]);\n      pid = getPID(i, ySize, this.pidSize);\n      this.boundarySets[DXN.DOWN].set(pid, [i, ySize]);\n    }\n  }\n\n  // Set this piece's controller\n  setController(controller) {\n    this.controller = controller;\n  }\n\n  // Generate a random index within SPAWN_OFFSET bounds; negative SPAWN_OFFSET guarantees spawnPosition is within the boundaries\n  spawnPosition() {\n    return randint(-SPAWN_OFFSET, this.boardSize + SPAWN_OFFSET);\n  }\n\n  // core rules of the game but is not very playable at all, nor does it have good objectives.\n  update(move) {\n    if (!gameOver) {}\n    if (move) {\n      if (this.placeBlock) {\n        // Place the current piece, create a new one, and check for new filled lines\n        this.placeCurrentPiece();\n        this.placeBlock = false;\n        this.gravity.turnLeft(1);\n        this.createNewPiece();\n        this.checkFilledLines(this.boardSize);\n\n        // TODO: This code can possibly be improved, both in terms of format and in isCleared removal.\n        this.targetBlocks.forEach(targetBlock => targetBlock.update());\n        this.targetBlocks.forEach(targetBlock => {\n          if (targetBlock.isFilled) {\n            targetBlock.clear(this.board, this.emptyValue);\n          } else if (targetBlock.isGameOver) {\n            this.gameOver = true;\n          }\n        });\n        var remainingTargets = [];\n        this.targetBlocks.forEach(targetBlock => {\n          if (!targetBlock.isCleared) {\n            remainingTargets.push(targetBlock);\n          }\n        });\n        this.targetBlocks = remainingTargets;\n        this.createNewTargetBlock();\n      } else {\n        // Move the current piece, first in its direction of gravity and second according to the player.\n        if (this.currPiece && this.collisionTimer == 0) {\n          this.currPiece.idleMove();\n        }\n      }\n    }\n    if (this.currPiece.checkCollision(this.currPiece.dxn.angle, this.board, this.boundarySets)) {\n      if (move) {\n        this.collisionTimer += 1;\n      }\n      if (this.collisionTimer == COLLISION_TIME_LIMIT) {\n        this.placeBlock = true;\n      }\n    } else {\n      this.collisionTimer = 0;\n    }\n    if (!this.placeBlock) {\n      if (this.currPiece && this.controller && !this.placeBlock) {\n        var action = this.controller.consumeAction();\n        if (action) {\n          this.executeAction(action);\n        }\n      }\n    }\n    this.timer += 1;\n    return this; // CoreState.update() returns itself \n  }\n\n  executeAction(action) {\n    if (action.type == ActionType.MOVE) {\n      if (this.currPiece.checkCollision(action.props.angle, this.board, this.boundarySets)) {\n        while (this.currPiece.checkCollision(action.props.angle, this.board, this.boundarySets)) {\n          this.currPiece.activeMove((action.props.angle + 2) % 4);\n        }\n      }\n      this.currPiece.activeMove(action.props.angle);\n    } else if (action.type == ActionType.ROTATE) {\n      this.currPiece.rotate(action.props.angle);\n      if (this.currPiece.checkCollision(null, this.board, this.boundarySets)) {\n        this.currPiece.rotate(-action.props.angle);\n      }\n    } else if (action.type == ActionType.PLACE) {\n      this.placeBlock = true;\n    }\n    return this;\n  }\n\n  // Change the CoreState's grid values based on where the current piece is.\n  placeCurrentPiece() {\n    if (this.currPiece != null) {\n      var [x, y] = [0, 0];\n      for (const cell of this.currPiece.cells) {\n        [x, y] = [cell[1][0] + this.currPiece.cx, cell[1][1] + this.currPiece.cy];\n        if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize) {\n          this.board[y][x] = this.currPiece.createCell();\n        }\n      }\n    }\n  }\n  createNewTargetBlock() {\n    var [x, y] = [this.spawnPosition(), this.spawnPosition()];\n    var targetBlock = new TargetBlock({\n      coreState: this,\n      x0: x - 1,\n      y0: y - 1,\n      x1: x + 1,\n      y1: y + 1\n    });\n    this.targetBlocks.push(targetBlock);\n  }\n\n  // Create a new piece based on this CoreState's gravity, at a random location.\n  createNewPiece() {\n    var [x, y] = [0, 0];\n    var r = this.spawnPosition();\n    if (this.gravity.angle == DXN.RIGHT) {\n      [x, y] = [-SPAWN_OFFSET, r];\n    } else if (this.gravity.angle == DXN.UP) {\n      [x, y] = [r, SPAWN_OFFSET + this.boardSize];\n    } else if (this.gravity.angle == DXN.LEFT) {\n      [x, y] = [SPAWN_OFFSET + this.boardSize, r];\n    } else if (this.gravity.angle == DXN.DOWN) {\n      [x, y] = [r, -SPAWN_OFFSET];\n    }\n    // Create the new piece\n    this.currPiece = new Piece({\n      center_x: x,\n      center_y: y,\n      angle: this.gravity.angle,\n      pieceSize: PIECE_SIZE,\n      pidSize: this.pidSize\n    });\n  }\n\n  // Check for filled lines within a certain threshold and clear them Tetris-style, based\n  // on the current direction of gravity.\n  checkFilledLines(threshold) {\n    var angle = this.currPiece.dxn.angle;\n    if (angle % 2 == 0) {\n      for (var x = 0; x < this.boardSize; x++) {\n        var count = 0;\n        for (var y = 0; y < this.boardSize; y++) {\n          if (this.board[y][x].type > 0) {\n            count += 1;\n          }\n        }\n        // Horizontally shift the left or the right of the cleared line\n        if (count >= threshold) {\n          if (angle % 4 == DXN.RIGHT) {\n            for (var j = 0; j < x; j++) {\n              i = x - j - 1;\n              for (var y_ = 0; y_ < this.boardSize; y_++) {\n                this.board[y_][i + 1] = this.board[y_][i];\n              }\n            }\n            for (var y_ = 0; y_ < this.boardSize; y_++) {\n              this.board[y_][0] = new Cell(0, {});\n            }\n          } else {\n            for (var i = x + 1; i < this.boardSize; i++) {\n              for (var y_ = 0; y_ < this.boardSize; y_++) {\n                this.board[y_][i - 1] = this.board[y_][i];\n              }\n            }\n            for (var y_ = 0; y_ < this.boardSize; y_++) {\n              this.board[y_][this.boardSize - 1] = new Cell(0, {});\n            }\n          }\n        }\n      }\n    } else {\n      for (var y = 0; y < this.boardSize; y++) {\n        var count = 0;\n        for (var x = 0; x < this.boardSize; x++) {\n          if (this.board[y][x].type > 0) {\n            count += 1;\n          }\n        }\n        // Horizontally shift the left or the right of the cleared line\n        if (count >= threshold) {\n          if (angle % 4 == DXN.DOWN) {\n            for (var j = 0; j < y; j++) {\n              i = y - j - 1;\n              for (var x_ = 0; x_ < this.boardSize; x_++) {\n                this.board[i + 1][x_] = this.board[i][x_];\n              }\n            }\n            for (var x_ = 0; x_ < this.boardSize; x_++) {\n              this.board[0][x_] = new Cell(0, {});\n            }\n          } else {\n            for (var i = y + 1; i < this.boardSize; i++) {\n              for (var x_ = 0; x_ < this.boardSize; x_++) {\n                this.board[i - 1][x_] = this.board[i][x_];\n              }\n            }\n            for (var x_ = 0; x_ < this.boardSize; x_++) {\n              this.board[this.boardSize - 1][x_] = new Cell(0, {});\n            }\n          }\n          break;\n        }\n      }\n    }\n  }\n};\nexport default CoreState;","map":{"version":3,"names":["Cell","Piece","TargetBlock","randint","getPID","Direction","DXN","ActionType","PIECE_SIZE","SPAWN_OFFSET","BOUNDARY_MARGIN","COLLISION_TIME_LIMIT","CoreState","constructor","props","controller","timer","boardSize","emptyValue","board","Array","map","e","fill","pidSize","gravity","LEFT","placeBlock","currPiece","targetBlocks","collisionTimer","isGameOver","xSize","ySize","pid","boundarySets","i","push","Map","RIGHT","set","UP","DOWN","setController","spawnPosition","update","move","gameOver","placeCurrentPiece","turnLeft","createNewPiece","checkFilledLines","forEach","targetBlock","isFilled","clear","remainingTargets","isCleared","createNewTargetBlock","idleMove","checkCollision","dxn","angle","action","consumeAction","executeAction","type","MOVE","activeMove","ROTATE","rotate","PLACE","x","y","cell","cells","cx","cy","createCell","coreState","x0","y0","x1","y1","r","center_x","center_y","pieceSize","threshold","count","j","y_","x_"],"sources":["/Users/joeyzhu/code/Pentaquad/src/components/game/coreState/CoreState.js"],"sourcesContent":["import Cell from \"./Cell\"\nimport Piece from \"./Piece\"\nimport TargetBlock from \"./TargetBlock\"\n\nimport { randint, getPID, Direction, DXN } from \"./Utils\"\nimport { ActionType } from \"./GameAction\"\n\n// Number of cells in each piece.\nconst PIECE_SIZE = 5;\n// The distance from the boundary that each piece \nconst SPAWN_OFFSET = -3;\n// Extend edge boundaries a bit further out of the grid to make sure\n// pieces spawning on the edge can still hit the ground.\nconst BOUNDARY_MARGIN = 4;\n// The number of ticks contact must take place in order to place a piece.\nconst COLLISION_TIME_LIMIT = 20;\n\n// The most essential level of state in the game. Each update() call either\n// moves an existing block, or places it and creates a new block after shifting\n// gravity. \n\nconst CoreState = class {\n    constructor (props) {\n        // The GameState's main controller\n        this.controller = null;\n        // A timer that increments once each update; updates should only be called from a higher-level state which is allowed to control the flow of \"core\" tempo.\n        this.timer = 0;\n        // The dimension of the square board on which this game takes place.\n        this.boardSize = props.boardSize;\n        // The default \"empty\" value of this grid: a type-0 Cell with no props\n        this.emptyValue = () => new Cell(0, {}); \n        // The main board on which everything happens\n        this.board = [...Array(props.boardSize)].map(e => Array(props.boardSize).fill(this.emptyValue()));\n        // All sets of (x, y) pairs checking each other for collisions will have a unique PID dependent on a 3rd parameter describing the max size of the PID group, in order for uniqueness to work.\n        this.pidSize = (props.boardSize + BOUNDARY_MARGIN * 2) * 2;\n        // The direction in which the piece moves, and in which the board moves after a line is cleared.\n        this.gravity = new Direction(DXN.LEFT);\n        // Flag for placing a block\n        this.placeBlock = true;\n        // The GameState's current unplaced piece\n        this.currPiece = null;\n        // The GameState's roster of target blocks\n        this.targetBlocks = [];\n        // Keep track of how long this piece is in contact in its falling direction\n        this.collisionTimer = 0;\n        // GameOver flag\n        this.isGameOver = false\n\n\n        // Create 4 different sets to check if a boundary has been hit\n        var [xSize, ySize] = [props.boardSize, props.boardSize]\n        var pid;\n        this.boundarySets = [];\n        for (var i = 0; i < 4; i++) {\n            this.boundarySets.push(new Map())\n        }\n        for (var i = -BOUNDARY_MARGIN; i < ySize + BOUNDARY_MARGIN; i++) {\n            pid = getPID(xSize, i, this.pidSize);\n            this.boundarySets[DXN.RIGHT].set(pid, [xSize, i])\n\n            pid = getPID(i, -1, this.pidSize);\n            this.boundarySets[DXN.UP].set(pid, [i, -1])\n\n            pid = getPID(-1, i, this.pidSize);\n            this.boundarySets[DXN.LEFT].set(pid, [-1, i])\n\n            pid = getPID(i, ySize, this.pidSize);\n            this.boundarySets[DXN.DOWN].set(pid, [i, ySize])\n        }\n    }\n\n    // Set this piece's controller\n    setController(controller) {\n        this.controller = controller\n    }\n\n    // Generate a random index within SPAWN_OFFSET bounds; negative SPAWN_OFFSET guarantees spawnPosition is within the boundaries\n    spawnPosition() {\n        return randint(-SPAWN_OFFSET, this.boardSize + SPAWN_OFFSET)\n    }\n\n    // core rules of the game but is not very playable at all, nor does it have good objectives.\n    update(move) {\n        if (!gameOver) {\n            \n        }\n        if (move) {\n            if (this.placeBlock) {\n                // Place the current piece, create a new one, and check for new filled lines\n                this.placeCurrentPiece();\n                this.placeBlock = false;\n                this.gravity.turnLeft(1);\n\n                this.createNewPiece();\n                this.checkFilledLines(this.boardSize);\n\n                // TODO: This code can possibly be improved, both in terms of format and in isCleared removal.\n                this.targetBlocks.forEach(targetBlock => targetBlock.update())\n                this.targetBlocks.forEach(targetBlock => {\n                    if (targetBlock.isFilled) {\n                        targetBlock.clear(this.board, this.emptyValue)\n                    } else if (targetBlock.isGameOver) {\n                        this.gameOver = true\n                    }\n                })\n                var remainingTargets = []\n                this.targetBlocks.forEach(targetBlock => {\n                    if (!targetBlock.isCleared) {\n                        remainingTargets.push(targetBlock)\n                    }\n                })\n                this.targetBlocks = remainingTargets\n\n                this.createNewTargetBlock();\n            } else {\n                // Move the current piece, first in its direction of gravity and second according to the player.\n                if (this.currPiece && this.collisionTimer == 0) {\n                    this.currPiece.idleMove()\n                }\n            }\n        }\n        if (this.currPiece.checkCollision(this.currPiece.dxn.angle, this.board, this.boundarySets)) {\n            if (move) {\n                this.collisionTimer += 1\n            }\n            if (this.collisionTimer == COLLISION_TIME_LIMIT) {\n                this.placeBlock = true\n            }\n        } else {\n            this.collisionTimer = 0\n        }\n        if (!this.placeBlock) {\n            if (this.currPiece && this.controller && !this.placeBlock) {\n                var action = this.controller.consumeAction()\n                if (action) {\n                    this.executeAction(action)\n                }\n            }\n        }\n        this.timer += 1\n        return this; // CoreState.update() returns itself \n    }\n\n    executeAction(action) {\n        if (action.type == ActionType.MOVE) {\n            if (this.currPiece.checkCollision(action.props.angle, this.board, this.boundarySets)) {\n                while (this.currPiece.checkCollision(action.props.angle, this.board, this.boundarySets)) {\n                    this.currPiece.activeMove((action.props.angle + 2) % 4)\n                }\n            }\n            this.currPiece.activeMove(action.props.angle)\n\n        } else if (action.type == ActionType.ROTATE) {\n            this.currPiece.rotate(action.props.angle)\n            if (this.currPiece.checkCollision(null, this.board, this.boundarySets)) {\n                this.currPiece.rotate(-action.props.angle)\n            }\n\n        } else if (action.type == ActionType.PLACE) {\n            this.placeBlock = true\n        }\n        return this;\n    }\n\n    // Change the CoreState's grid values based on where the current piece is.\n    placeCurrentPiece() {\n        if (this.currPiece != null) {\n            var [x, y] = [0, 0]\n            for (const cell of this.currPiece.cells) {\n                [x, y] = [cell[1][0] + this.currPiece.cx, cell[1][1] + this.currPiece.cy]\n                if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize) {\n                    this.board[y][x] = this.currPiece.createCell()\n                }\n            }\n        }\n    }\n\n    createNewTargetBlock() {\n        var [x, y] = [this.spawnPosition(), this.spawnPosition()]\n        var targetBlock = new TargetBlock({\n            coreState: this,\n            x0: x - 1,\n            y0: y - 1,\n            x1: x + 1,\n            y1: y + 1,\n        })\n        this.targetBlocks.push(targetBlock)\n    }\n\n    // Create a new piece based on this CoreState's gravity, at a random location.\n    createNewPiece() {\n        var [x, y] = [0, 0]\n        var r = this.spawnPosition()\n        if (this.gravity.angle == DXN.RIGHT) {\n            [x, y] = [-SPAWN_OFFSET, r]\n        } else if (this.gravity.angle == DXN.UP) {\n            [x, y] = [r, SPAWN_OFFSET + this.boardSize]\n        } else if (this.gravity.angle == DXN.LEFT) {\n            [x, y] = [SPAWN_OFFSET + this.boardSize, r]\n        } else if (this.gravity.angle == DXN.DOWN) {\n            [x, y] = [r, -SPAWN_OFFSET]\n        }\n        // Create the new piece\n        this.currPiece = new Piece({\n            center_x: x,\n            center_y: y,\n            angle: this.gravity.angle,\n            pieceSize: PIECE_SIZE,\n            pidSize: this.pidSize,\n        })\n    }\n\n    // Check for filled lines within a certain threshold and clear them Tetris-style, based\n    // on the current direction of gravity.\n    checkFilledLines(threshold) {\n        var angle = this.currPiece.dxn.angle\n        if (angle % 2 == 0) {\n            for (var x = 0; x < this.boardSize; x++) {\n                var count = 0;\n                for (var y = 0; y < this.boardSize; y++) {\n                    if (this.board[y][x].type > 0) {\n                        count += 1;\n                    }\n                }\n                // Horizontally shift the left or the right of the cleared line\n                if (count >= threshold) {\n                    if (angle % 4 == DXN.RIGHT) {\n                        for (var j = 0; j < x; j++) {\n                            i = x - j - 1\n                            for (var y_ = 0; y_ < this.boardSize; y_++) {\n                                this.board[y_][i + 1] = this.board[y_][i]\n                            }\n                        }\n                        for (var y_ = 0; y_ < this.boardSize; y_++) {\n                            this.board[y_][0] = new Cell(0, {})\n                        }\n                    } else {\n                        for (var i = x + 1; i < this.boardSize; i++) {\n                            for (var y_ = 0; y_ < this.boardSize; y_++) {\n                                this.board[y_][i - 1] = this.board[y_][i]\n                            }\n                        }\n                        for (var y_ = 0; y_ < this.boardSize; y_++) {\n                            this.board[y_][this.boardSize - 1] = new Cell(0, {})\n                        }\n                    }\n                }\n            }\n        } else {\n            for (var y = 0; y < this.boardSize; y++) {\n                var count = 0;\n                for (var x = 0; x < this.boardSize; x++) {\n                    if (this.board[y][x].type > 0) {\n                        count += 1;\n                    }\n                }\n                // Horizontally shift the left or the right of the cleared line\n                if (count >= threshold) {\n                    if (angle % 4 == DXN.DOWN) {\n                        for (var j = 0; j < y; j++) {\n                            i = y - j - 1\n                            for (var x_ = 0; x_ < this.boardSize; x_++) {\n                                this.board[i + 1][x_] = this.board[i][x_]\n                            }\n                        }\n                        for (var x_ = 0; x_ < this.boardSize; x_++) {\n                            this.board[0][x_] = new Cell(0, {})\n                        }\n                    } else {\n                        for (var i = y + 1; i < this.boardSize; i++) {\n                            for (var x_ = 0; x_ < this.boardSize; x_++) {\n                                this.board[i - 1][x_] = this.board[i][x_]\n                            }\n                        }\n                        for (var x_ = 0; x_ < this.boardSize; x_++) {\n                            this.board[this.boardSize - 1][x_] = new Cell(0, {})\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n}\n\nexport default CoreState\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}