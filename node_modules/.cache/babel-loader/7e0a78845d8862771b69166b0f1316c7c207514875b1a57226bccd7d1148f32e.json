{"ast":null,"code":"import Direction from \"./gameUtils/Direction\";\nimport Piece from \"./gameUtils/Piece\";\n\n// TODO: Pull up this function into a utils/functions file\nfunction randint(a, b) {\n  return Math.floor(Math.random() * (b - a)) + a;\n}\nconst Gravity = {\n  RIGHT: 0,\n  UP: 1,\n  LEFT: 2,\n  DOWN: 3\n};\nconst ActionType = {\n  MOVE: 0,\n  PLACE: 1\n};\nfunction getPID(x, y, groupSize) {\n  return x * groupSize + y;\n}\nconst PIECE_SIZE = 5;\nconst SPAWN_OFFSET = 2;\nconst BOUNDARY_MARGIN = 4;\nconst GameState = class {\n  constructor(props) {\n    this.timer = 0;\n    this.emptyValue = 0;\n    this.board = [...Array(props.boardSize)].map(e => Array(props.boardSize).fill(this.emptyValue));\n    this.boardSize = props.boardSize;\n    this.pidSize = (props.boardSize + SPAWN_OFFSET * 2) * 2;\n    this.gravity = new Direction(Gravity.DOWN);\n    this.placeBlock = true;\n    this.currPiece = null;\n\n    // Create 4 different sets to check if a boundary has been hit\n    var [xSize, ySize] = [props.boardSize, props.boardSize];\n    var pid;\n    this.boundarySets = [];\n    var boundarySet = new Map();\n    for (var y = -BOUNDARY_MARGIN; y < ySize + BOUNDARY_MARGIN; y++) {\n      pid = getPID(xSize, y, this.pidSize);\n      boundarySet.set(pid, [xSize, y]);\n    }\n    this.boundarySets.push(boundarySet);\n    boundarySet = new Map();\n    for (var x = -BOUNDARY_MARGIN; x < xSize + BOUNDARY_MARGIN; x++) {\n      pid = getPID(x, -1, this.pidSize);\n      boundarySet.set(pid, [x, -1]);\n    }\n    this.boundarySets.push(boundarySet);\n    boundarySet = new Map();\n    for (var y = -BOUNDARY_MARGIN; y < ySize + BOUNDARY_MARGIN; y++) {\n      pid = getPID(-1, y, this.pidSize);\n      boundarySet.set(pid, [-1, y]);\n    }\n    this.boundarySets.push(boundarySet);\n    boundarySet = new Map();\n    for (var x = -BOUNDARY_MARGIN; x < xSize + BOUNDARY_MARGIN; x++) {\n      pid = getPID(x, ySize, this.pidSize);\n      boundarySet.set(pid, [x, ySize]);\n    }\n    this.boundarySets.push(boundarySet);\n  }\n  update() {\n    if (this.placeBlock) {\n      this.placeBlock = false;\n      var [x, y] = [0, 0];\n\n      // Place the current piece\n      if (this.currPiece != null) {\n        for (const cell of this.currPiece.cells) {\n          [x, y] = [cell[1][0] + this.currPiece.cx, cell[1][1] + this.currPiece.cy];\n          if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize) {\n            this.board[y][x] = this.currPiece.type;\n          }\n        }\n      }\n\n      // Set the position and gravity with which to create a new piece\n      this.gravity.turnLeft(1);\n      var r = randint(-SPAWN_OFFSET, this.boardSize + SPAWN_OFFSET);\n      // var r = Math.floor(this.boardSize / 2)\n      if (this.gravity.angle == Gravity.RIGHT) {\n        [x, y] = [-SPAWN_OFFSET, r];\n      } else if (this.gravity.angle == Gravity.UP) {\n        [x, y] = [r, SPAWN_OFFSET + this.boardSize];\n      } else if (this.gravity.angle == Gravity.LEFT) {\n        [x, y] = [SPAWN_OFFSET + this.boardSize, r];\n      } else if (this.gravity.angle == Gravity.DOWN) {\n        [x, y] = [r, -SPAWN_OFFSET];\n      }\n      this.currPiece = new Piece({\n        center_x: x,\n        center_y: y,\n        angle: this.gravity.angle,\n        pieceSize: PIECE_SIZE,\n        pidSize: this.pidSize\n      });\n    } else {\n      if (this.currPiece) {\n        this.currPiece.idleMove();\n        if (this.currPiece.checkCollision(this.currPiece.angle, this.board, this.boundarySets)) {\n          this.placeBlock = true;\n        }\n      }\n    }\n    return this;\n  }\n\n  // TODO: Call this.currPiece.activeMove and check for the collision in both idle and active directions\n  executeAction(action) {\n    if (action.actionType == ActionType.MOVE) {\n      this.piece.activeMove(action);\n    } else if (action.actionType == ActionType.PLACE) {\n      this.placeBlock = true;\n    }\n    return this;\n  }\n};\nexport default GameState;","map":{"version":3,"names":["Direction","Piece","randint","a","b","Math","floor","random","Gravity","RIGHT","UP","LEFT","DOWN","ActionType","MOVE","PLACE","getPID","x","y","groupSize","PIECE_SIZE","SPAWN_OFFSET","BOUNDARY_MARGIN","GameState","constructor","props","timer","emptyValue","board","Array","boardSize","map","e","fill","pidSize","gravity","placeBlock","currPiece","xSize","ySize","pid","boundarySets","boundarySet","Map","set","push","update","cell","cells","cx","cy","type","turnLeft","r","angle","center_x","center_y","pieceSize","idleMove","checkCollision","executeAction","action","actionType","piece","activeMove"],"sources":["/Users/joeyzhu/code/visuals/pentaquad/src/components/game/GameState.js"],"sourcesContent":["import Direction from \"./gameUtils/Direction\";\nimport Piece from \"./gameUtils/Piece\";\n\n// TODO: Pull up this function into a utils/functions file\nfunction randint(a, b) {\n    return Math.floor(Math.random() * (b - a)) + a;\n}\n\nconst Gravity = {\n    RIGHT: 0,\n    UP: 1,\n    LEFT: 2,\n    DOWN: 3,\n}\n\nconst ActionType = {\n    MOVE: 0,\n    PLACE: 1,\n}\n\n\nfunction getPID(x, y, groupSize) {\n    return x * groupSize + y;\n}\n\nconst PIECE_SIZE = 5;\nconst SPAWN_OFFSET = 2;\nconst BOUNDARY_MARGIN = 4;\n\n\nconst GameState = class {\n    constructor (props) {\n        this.timer = 0;\n        this.emptyValue = 0; \n        this.board = [...Array(props.boardSize)].map(e => Array(props.boardSize).fill(this.emptyValue));\n        this.boardSize = props.boardSize;\n        this.pidSize = (props.boardSize + SPAWN_OFFSET * 2) * 2;\n        this.gravity = new Direction(Gravity.DOWN);\n        this.placeBlock = true;\n        this.currPiece = null;\n\n        // Create 4 different sets to check if a boundary has been hit\n        var [xSize, ySize] = [props.boardSize, props.boardSize]\n        var pid;\n        this.boundarySets = [];\n        var boundarySet = new Map()\n        for (var y = -BOUNDARY_MARGIN; y < ySize + BOUNDARY_MARGIN; y++) {\n            pid = getPID(xSize, y, this.pidSize);\n            boundarySet.set(pid, [xSize, y])\n        }\n        this.boundarySets.push(boundarySet);\n\n        boundarySet = new Map()\n        for (var x = -BOUNDARY_MARGIN; x < xSize + BOUNDARY_MARGIN; x++) {\n            pid = getPID(x, -1, this.pidSize);\n            boundarySet.set(pid, [x, -1])\n        }\n        this.boundarySets.push(boundarySet);\n\n        boundarySet = new Map()\n        for (var y = -BOUNDARY_MARGIN; y < ySize + BOUNDARY_MARGIN; y++) {\n            pid = getPID(-1, y, this.pidSize);\n            boundarySet.set(pid, [-1, y])\n        }\n        this.boundarySets.push(boundarySet);\n\n        boundarySet = new Map()\n        for (var x = -BOUNDARY_MARGIN; x < xSize + BOUNDARY_MARGIN; x++) {\n            pid = getPID(x, ySize, this.pidSize);\n            boundarySet.set(pid, [x, ySize])\n        }\n        this.boundarySets.push(boundarySet);\n    }\n\n    update() {\n        if (this.placeBlock) {\n            this.placeBlock = false;\n            var [x, y] = [0, 0]\n\n            // Place the current piece\n            if (this.currPiece != null) {\n                for (const cell of this.currPiece.cells) {\n                    [x, y] = [cell[1][0] + this.currPiece.cx, cell[1][1] + this.currPiece.cy]\n                    if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize) {\n                        this.board[y][x] = this.currPiece.type\n                    }\n                }\n            }\n\n            // Set the position and gravity with which to create a new piece\n            this.gravity.turnLeft(1);\n            var r = randint(-SPAWN_OFFSET, this.boardSize + SPAWN_OFFSET)\n            // var r = Math.floor(this.boardSize / 2)\n            if (this.gravity.angle == Gravity.RIGHT) {\n                [x, y] = [-SPAWN_OFFSET, r]\n            } else if (this.gravity.angle == Gravity.UP) {\n                [x, y] = [r, SPAWN_OFFSET + this.boardSize]\n            } else if (this.gravity.angle == Gravity.LEFT) {\n                [x, y] = [SPAWN_OFFSET + this.boardSize, r]\n            } else if (this.gravity.angle == Gravity.DOWN) {\n                [x, y] = [r, -SPAWN_OFFSET]\n            }\n\n            this.currPiece = new Piece({\n                center_x: x,\n                center_y: y,\n                angle: this.gravity.angle,\n                pieceSize: PIECE_SIZE,\n                pidSize: this.pidSize,\n            })\n        } else {\n            if (this.currPiece) {\n                this.currPiece.idleMove()\n                if (this.currPiece.checkCollision(this.currPiece.angle, this.board, this.boundarySets)) {\n                    this.placeBlock = true\n                }\n            }\n        }\n        return this;\n    }\n\n    // TODO: Call this.currPiece.activeMove and check for the collision in both idle and active directions\n    executeAction(action) {\n        if (action.actionType == ActionType.MOVE) {\n            this.piece.activeMove(action)\n        } else if (action.actionType == ActionType.PLACE) {\n            this.placeBlock = true\n        }\n        return this;\n    }\n}\n\nexport default GameState;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}