{"ast":null,"code":"import Direction from \"./Direction\";\nimport Cell from \"./Cell\";\nimport { randint, getPID } from \"./Utils\";\nimport { Color } from \"../../../utils/colors\";\n\n// A single piece in the game\nclass Piece {\n  constructor(_ref) {\n    let {\n      center_x,\n      center_y,\n      angle,\n      pieceSize,\n      pidSize\n    } = _ref;\n    [this.cx, this.cy, this.dxn] = [center_x, center_y, new Direction(angle)];\n    this.pidSize = pidSize;\n    this.cells = new Map();\n    var [x, y, dxn] = [0, 0, new Direction(randint(0, 4))];\n    var pid = getPID(x, y, pidSize);\n    var turnAngle;\n    var valid;\n    for (var i = 0; i < pieceSize; i++) {\n      valid = false;\n      while (!valid) {\n        this.cells.set(pid, [x, y]);\n        turnAngle = randint(-1, 2);\n        dxn.turn(turnAngle);\n        x += dxn.dx;\n        y += dxn.dy;\n        pid = getPID(x, y, this.pidSize);\n        valid = this.cells.get(pid) == undefined;\n        if (!valid) {\n          x -= dxn.dx;\n          y -= dxn.dy;\n          dxn.turn(-turnAngle);\n        }\n      }\n    }\n\n    // Create 4 different sets to check hitboxes in different gravity\n    this.collisionSets = [];\n    dxn = new Direction(0);\n    var [x, y] = [0, 0];\n    var collisionSet;\n    for (var a = 0; a < 4; a++) {\n      collisionSet = new Map();\n      this.cells.forEach(val => {\n        [x, y] = [val[0] + dxn.dx, val[1] + dxn.dy];\n        pid = getPID(x, y, this.pidSize);\n        collisionSet.set(pid, [x, y]);\n      });\n      this.collisionSets.push(collisionSet);\n      dxn.turnLeft(1);\n    }\n    if (angle % 4 == 0) {\n      this.color = new Color({\n        red: 225,\n        green: 0,\n        blue: 105\n      });\n    } else if (angle % 4 == 1) {\n      this.color = new Color({\n        red: 255,\n        green: 125,\n        blue: 0\n      });\n    } else if (angle % 4 == 2) {\n      this.color = new Color({\n        red: 0,\n        green: 235,\n        blue: 175\n      });\n    } else if (angle % 4 == 3) {\n      this.color = new Color({\n        red: 0,\n        green: 200,\n        blue: 255\n      });\n    }\n  }\n  createCell() {\n    var cell = new Cell(1, {\n      parent: this\n    });\n    return cell;\n  }\n\n  // Return whether or not the block has a collision with this angle.\n  checkCollision(angle, board, boundarySets) {\n    var [xSize, ySize] = [board.length, board[0].length];\n    var collisionSet = this.collisionSets[angle];\n    var boundarySet = boundarySets[angle];\n    var collision = false;\n    // Check for a boundary collision\n    collisionSet.forEach(val => {\n      // BoundarySet has global PIDs\n      // CollisionSet Local PID: add cx and cy to collisionSet to globalize\n      var globalPid = getPID(val[0] + this.cx, val[1] + this.cy, this.pidSize);\n      if (!collision && boundarySet.has(globalPid)) {\n        collision = true;\n      }\n    });\n    if (collision == true) {\n      return true;\n    }\n\n    // Check for a board collision\n    for (var y = 0; y < ySize; y++) {\n      for (var x = 0; x < xSize; x++) {\n        if (board[y][x].type > 0) {\n          // x, y generate global PIDs\n          // Subtract cx and cy from PIDs to localize\n          var globalPid = getPID(x - this.cx, y - this.cy, this.pidSize);\n          if (!collision && collisionSet.has(globalPid)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Move this piece based on a given x and y direction and recheck its appropriate hitbox\n  activeMove(angle) {\n    var adxn = new Direction(angle);\n    this.cx += adxn.dx;\n    this.cy += adxn.dy;\n  }\n\n  // Move this piece based on its gravity and recheck its appropriate hitbox.\n  idleMove() {\n    this.cx += this.dxn.dx;\n    this.cy += this.dxn.dy;\n  }\n}\nexport default Piece;","map":{"version":3,"names":["Direction","Cell","randint","getPID","Color","Piece","constructor","_ref","center_x","center_y","angle","pieceSize","pidSize","cx","cy","dxn","cells","Map","x","y","pid","turnAngle","valid","i","set","turn","dx","dy","get","undefined","collisionSets","collisionSet","a","forEach","val","push","turnLeft","color","red","green","blue","createCell","cell","parent","checkCollision","board","boundarySets","xSize","ySize","length","boundarySet","collision","globalPid","has","type","activeMove","adxn","idleMove"],"sources":["/Users/joeyzhu/code/visuals/pentaquad/src/components/game/gameUtils/Piece.js"],"sourcesContent":["import Direction from \"./Direction\";\nimport Cell from \"./Cell\";\nimport { randint, getPID } from \"./Utils\";\nimport { Color } from \"../../../utils/colors\";\n\n// A single piece in the game\nclass Piece {\n    constructor({\n        center_x, \n        center_y, \n        angle, \n        pieceSize, \n        pidSize\n    }) {\n        [this.cx, this.cy, this.dxn] = [center_x, center_y, new Direction(angle)];\n        this.pidSize = pidSize;\n\n        this.cells = new Map();\n        var [x, y, dxn] = [0, 0, new Direction(randint(0, 4))];\n        var pid = getPID(x, y, pidSize);\n        var turnAngle;\n        var valid;\n        for (var i = 0; i < pieceSize; i++) {\n            valid = false;\n            while (!valid) {\n                this.cells.set(pid, [x, y])\n                turnAngle = randint(-1, 2)\n                dxn.turn(turnAngle)\n                x += dxn.dx\n                y += dxn.dy\n                pid = getPID(x, y, this.pidSize)\n                valid = this.cells.get(pid) == undefined\n                if (!valid) {\n                    x -= dxn.dx\n                    y -= dxn.dy\n                    dxn.turn(-turnAngle)\n                }\n            }\n        }\n\n        // Create 4 different sets to check hitboxes in different gravity\n        this.collisionSets = [];\n        dxn = new Direction(0);\n        var [x, y] = [0, 0]\n        var collisionSet;\n        for (var a = 0; a < 4; a++) {\n            collisionSet = new Map();\n            this.cells.forEach((val) => {\n                [x, y] = [val[0] + dxn.dx, val[1] + dxn.dy]\n                pid = getPID(x, y, this.pidSize);\n                collisionSet.set(pid, [x, y]);\n            })\n            this.collisionSets.push(collisionSet)\n            dxn.turnLeft(1);\n        }\n\n        if (angle % 4 == 0) {\n            this.color = new Color({ red: 225, green: 0, blue: 105})\n        } else if (angle % 4 == 1) {\n            this.color = new Color({ red: 255, green: 125, blue: 0})\n        } else if (angle % 4 == 2) {\n            this.color = new Color({ red: 0, green: 235, blue: 175})\n        } else if (angle % 4 == 3) {\n            this.color = new Color({ red: 0, green: 200, blue: 255})\n        }  \n    }\n\n    createCell() {\n        var cell = new Cell(1, {parent: this});\n        return cell;\n    }\n\n    // Return whether or not the block has a collision with this angle.\n    checkCollision(angle, board, boundarySets) {\n\n        var [xSize, ySize] = [board.length, board[0].length];\n        var collisionSet = this.collisionSets[angle];\n        var boundarySet = boundarySets[angle];\n        var collision = false;\n        // Check for a boundary collision\n        collisionSet.forEach((val) => {\n            // BoundarySet has global PIDs\n            // CollisionSet Local PID: add cx and cy to collisionSet to globalize\n            var globalPid = getPID(val[0] + this.cx, val[1] + this.cy, this.pidSize)\n            if (!collision && boundarySet.has(globalPid)) {\n                collision = true;\n            }\n        })\n        if (collision == true) {\n            return true;\n        }\n\n        // Check for a board collision\n        for (var y = 0; y < ySize; y++) {\n            for (var x = 0; x < xSize; x++) {\n                if (board[y][x].type > 0) {\n                    // x, y generate global PIDs\n                    // Subtract cx and cy from PIDs to localize\n                    var globalPid = getPID(x - this.cx, y - this.cy, this.pidSize)\n                    if (!collision && collisionSet.has(globalPid)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    // Move this piece based on a given x and y direction and recheck its appropriate hitbox\n    activeMove(angle) {\n        var adxn = new Direction(angle);\n        this.cx += adxn.dx;\n        this.cy += adxn.dy;\n    }\n\n    // Move this piece based on its gravity and recheck its appropriate hitbox.\n    idleMove() {\n        this.cx += this.dxn.dx;\n        this.cy += this.dxn.dy;\n    }\n}\n\nexport default Piece;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}