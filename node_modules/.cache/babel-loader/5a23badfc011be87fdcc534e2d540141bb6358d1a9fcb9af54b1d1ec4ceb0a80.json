{"ast":null,"code":"import Cell from \"./Cell\";\nimport { randint, getPID, Direction, DXN, NULL_DXN } from \"./Utils\";\nimport { Color } from \"../graphics/Colors\";\n\n// A single piece in the game, which can move in different directions and detect collisions\n// based on which direction is moving.\nclass Piece {\n  constructor(_ref) {\n    let {\n      center_x,\n      center_y,\n      angle,\n      pieceSize,\n      pidSize\n    } = _ref;\n    [this.cx, this.cy, this.dxn] = [center_x, center_y, new Direction(angle)];\n    this.pidSize = pidSize;\n\n    // Create some arrangement of 5 contiguous cells.\n    // TODO: It would be faster/easier to pull from a set of all possible existing cells\n    this.cells = new Map();\n    var [x, y, dxn] = [0, 0, new Direction(randint(0, 4))];\n    var pid = getPID(x, y, pidSize);\n    var turnAngle;\n    var valid;\n    for (var i = 0; i < pieceSize; i++) {\n      valid = false;\n      while (!valid) {\n        this.cells.set(pid, [x, y]);\n        turnAngle = randint(-1, 2);\n        dxn.turn(turnAngle);\n        x += dxn.dx;\n        y += dxn.dy;\n        pid = getPID(x, y, this.pidSize);\n        valid = this.cells.get(pid) == undefined;\n        if (!valid) {\n          x -= dxn.dx;\n          y -= dxn.dy;\n          dxn.turn(-turnAngle);\n        }\n      }\n    }\n\n    // Create 4 different sets to check hitboxes in different gravity\n    this.collisionSets = [];\n    dxn = new Direction(0);\n    var [x, y] = [0, 0];\n    var collisionSet;\n    for (var a = 0; a < 4; a++) {\n      collisionSet = new Map();\n      this.cells.forEach(val => {\n        [x, y] = [val[0] + dxn.dx, val[1] + dxn.dy];\n        pid = getPID(x, y, this.pidSize);\n        collisionSet.set(pid, [x, y]);\n      });\n      this.collisionSets.push(collisionSet);\n      dxn.turnLeft(1);\n    }\n\n    // Set this piece's color based on its initial direction; there will be more\n    // room to customize this.\n    if (angle % 4 == DXN.RIGHT) {\n      this.color = new Color({\n        red: 225,\n        green: 0,\n        blue: 105\n      });\n    } else if (angle % 4 == DXN.UP) {\n      this.color = new Color({\n        red: 255,\n        green: 125,\n        blue: 0\n      });\n    } else if (angle % 4 == DXN.LEFT) {\n      this.color = new Color({\n        red: 0,\n        green: 235,\n        blue: 175\n      });\n    } else if (angle % 4 == DXN.DOWN) {\n      this.color = new Color({\n        red: 0,\n        green: 200,\n        blue: 235\n      });\n    }\n  }\n\n  // The function to fill the coreState with cells corresponding to this Piece; this will\n  // be used for cases like the render script accessing the color in the parents\n  createCell() {\n    var cell = new Cell(1, {\n      parent: this\n    });\n    return cell;\n  }\n\n  // Return whether or not the block has a collision with this angle.\n  // Null angle option is for rotation collision check, only to make sure that the piece\n  // doesn't rotate into any overlaps with filled cells.\n  checkCollision(angle, board, boundarySets) {\n    var [xSize, ySize] = [board.length, board[0].length];\n    var collisionSet = angle == null ? this.cells : this.collisionSets[angle];\n    var collisionDxn = angle == null ? {\n      dx: 0,\n      dy: 0\n    } : new Direction(angle);\n    var boundarySet = boundarySets[angle];\n    var collision = false;\n\n    // Check for a boundary collision\n    collisionSet.forEach(val => {\n      var globalPid = getPID(val[0] + this.cx + collisionDxn.dx, val[1] + this.cy + collisionDxn.dy, this.pidSize);\n      if (!collision && boundarySet.has(globalPid)) {\n        collision = true;\n      }\n    });\n    if (collision == true) {\n      return true;\n    }\n\n    // Check for a board collision\n    for (var y = 0; y < ySize; y++) {\n      for (var x = 0; x < xSize; x++) {\n        if (board[y][x].type > 0) {\n          // x, y generate global PIDs\n          // Subtract cx and cy from PIDs to localize\n          var globalPid = getPID(x - this.cx - collisionDxn.dx, y - this.cy - this.collisionDxn.dy, this.pidSize);\n          if (!collision && collisionSet.has(globalPid)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Move this piece based on a given x and y direction and recheck its appropriate hitbox\n  activeMove(angle) {\n    var adxn = new Direction(angle);\n    this.cx += adxn.dx;\n    this.cy += adxn.dy;\n  }\n\n  // Move this piece based on its gravity and recheck its appropriate hitbox.\n  idleMove() {\n    this.cx += this.dxn.dx;\n    this.cy += this.dxn.dy;\n  }\n  rotate(angle) {\n    if (angle - 1) {}\n  }\n  rotateRight(angle) {}\n  rotateLeft(angle) {}\n}\nexport default Piece;","map":{"version":3,"names":["Cell","randint","getPID","Direction","DXN","NULL_DXN","Color","Piece","constructor","_ref","center_x","center_y","angle","pieceSize","pidSize","cx","cy","dxn","cells","Map","x","y","pid","turnAngle","valid","i","set","turn","dx","dy","get","undefined","collisionSets","collisionSet","a","forEach","val","push","turnLeft","RIGHT","color","red","green","blue","UP","LEFT","DOWN","createCell","cell","parent","checkCollision","board","boundarySets","xSize","ySize","length","collisionDxn","boundarySet","collision","globalPid","has","type","activeMove","adxn","idleMove","rotate","rotateRight","rotateLeft"],"sources":["/Users/joeyzhu/code/Pentaquad/src/components/game/coreState/Piece.js"],"sourcesContent":["import Cell from \"./Cell\";\nimport { randint, getPID, Direction, DXN, NULL_DXN } from \"./Utils\";\nimport { Color } from \"../graphics/Colors\";\n\n// A single piece in the game, which can move in different directions and detect collisions\n// based on which direction is moving.\nclass Piece {\n    constructor({\n        center_x, \n        center_y, \n        angle, \n        pieceSize, \n        pidSize\n    }) {\n        [this.cx, this.cy, this.dxn] = [center_x, center_y, new Direction(angle)];\n        this.pidSize = pidSize;\n\n        // Create some arrangement of 5 contiguous cells.\n        // TODO: It would be faster/easier to pull from a set of all possible existing cells\n        this.cells = new Map();\n        var [x, y, dxn] = [0, 0, new Direction(randint(0, 4))];\n        var pid = getPID(x, y, pidSize);\n        var turnAngle;\n        var valid;\n        for (var i = 0; i < pieceSize; i++) {\n            valid = false;\n            while (!valid) {\n                this.cells.set(pid, [x, y])\n                turnAngle = randint(-1, 2)\n                dxn.turn(turnAngle)\n                x += dxn.dx\n                y += dxn.dy\n                pid = getPID(x, y, this.pidSize)\n                valid = this.cells.get(pid) == undefined\n                if (!valid) {\n                    x -= dxn.dx\n                    y -= dxn.dy\n                    dxn.turn(-turnAngle)\n                }\n            }\n        }\n\n        // Create 4 different sets to check hitboxes in different gravity\n        this.collisionSets = [];\n        dxn = new Direction(0);\n        var [x, y] = [0, 0]\n        var collisionSet;\n        for (var a = 0; a < 4; a++) {\n            collisionSet = new Map();\n            this.cells.forEach((val) => {\n                [x, y] = [val[0] + dxn.dx, val[1] + dxn.dy]\n                pid = getPID(x, y, this.pidSize);\n                collisionSet.set(pid, [x, y]);\n            })\n            this.collisionSets.push(collisionSet)\n            dxn.turnLeft(1);\n        }\n\n        // Set this piece's color based on its initial direction; there will be more\n        // room to customize this.\n        if (angle % 4 == DXN.RIGHT) {\n            this.color = new Color({ red: 225, green: 0, blue: 105})\n        } else if (angle % 4 == DXN.UP) {\n            this.color = new Color({ red: 255, green: 125, blue: 0})\n        } else if (angle % 4 == DXN.LEFT) {\n            this.color = new Color({ red: 0, green: 235, blue: 175})\n        } else if (angle % 4 == DXN.DOWN) {\n            this.color = new Color({ red: 0, green: 200, blue: 235})\n        }  \n    }\n\n    // The function to fill the coreState with cells corresponding to this Piece; this will\n    // be used for cases like the render script accessing the color in the parents\n    createCell() {\n        var cell = new Cell(1, {parent: this});\n        return cell;\n    }\n\n    // Return whether or not the block has a collision with this angle.\n    // Null angle option is for rotation collision check, only to make sure that the piece\n    // doesn't rotate into any overlaps with filled cells.\n    checkCollision(angle, board, boundarySets) {\n        var [xSize, ySize] = [board.length, board[0].length];\n        var collisionSet = angle == null ? this.cells : this.collisionSets[angle];\n\n        var collisionDxn = angle == null ? { dx: 0, dy: 0 } : new Direction(angle)\n\n        var boundarySet = boundarySets[angle];\n        var collision = false;\n\n        // Check for a boundary collision\n        collisionSet.forEach((val) => {\n            var globalPid = getPID(\n                val[0] + this.cx + collisionDxn.dx, \n                val[1] + this.cy + collisionDxn.dy, \n                this.pidSize)\n            if (!collision && boundarySet.has(globalPid)) {\n                collision = true;\n            }\n        })\n        if (collision == true) {\n            return true;\n        }\n\n        // Check for a board collision\n        for (var y = 0; y < ySize; y++) {\n            for (var x = 0; x < xSize; x++) {\n                if (board[y][x].type > 0) {\n                    // x, y generate global PIDs\n                    // Subtract cx and cy from PIDs to localize\n                    var globalPid = getPID(\n                        x - this.cx - collisionDxn.dx, \n                        y - this.cy - this.collisionDxn.dy, \n                        this.pidSize)\n                    if (!collision && collisionSet.has(globalPid)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    // Move this piece based on a given x and y direction and recheck its appropriate hitbox\n    activeMove(angle) {\n        var adxn = new Direction(angle);\n        this.cx += adxn.dx;\n        this.cy += adxn.dy;\n    }\n\n    // Move this piece based on its gravity and recheck its appropriate hitbox.\n    idleMove() {\n        this.cx += this.dxn.dx;\n        this.cy += this.dxn.dy;\n    }\n\n    rotate(angle) {\n        if (angle  -1) {\n\n        } \n    }\n\n    rotateRight(angle) {\n\n    }\n\n    rotateLeft(angle) {\n\n    }\n}\n\nexport default Piece;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}