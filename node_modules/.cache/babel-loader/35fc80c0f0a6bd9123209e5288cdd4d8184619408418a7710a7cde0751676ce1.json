{"ast":null,"code":"const DEFAULT_TICKS_TO_GROWTH = 4;\n\n// The primary objective of this game is not to fill up lines but to fill up rectangle-shaped TargetBlocks,\n// which grow over time and end the game once they exceed the bounds of the board. \nclass TargetBlock {\n  constructor(props) {\n    [this.x0, this.y0, this.x1, this.y1] = [props.x0, props.y0, props.x1, props.y1];\n    this.coreState = props.coreState;\n    this.boardSize = props.coreState.boardSize;\n    this.ticksToGrowth = props.ticksToGrowth ? props.ticksToGrowth : DEFAULT_TICKS_TO_GROWTH;\n    this.ticksLeft = this.ticksToGrowth;\n    this.isGameOver = false;\n    this.isFilled = false;\n    this.isCleared = false;\n  }\n\n  // To be called once each time the coreState updates\n  update() {\n    if (this.checkFill(this.coreState.board)) this.ticksLeft -= 1;\n    if (this.ticksLeft == 0) {\n      this.ticksLeft = this.ticksToGrowth;\n      this.grow();\n    }\n  }\n\n  // Extend the corners out by one cell. If any corner leaves the bounds of the game's board, GameOver flag goes up.\n  grow() {\n    this.x0 -= 1;\n    this.y0 -= 1;\n    this.x1 += 1;\n    this.y1 += 1;\n    if (this.x0 < 0 || this.y0 < 0 || this.x1 >= this.boardSize || this.y1 >= this.boardSize) {\n      this.isGameOver = true;\n    }\n  }\n\n  // Check that every spot covered by this TargetBlock is \"filled\" with a Cell of type > 0, signifying that \n  // it is not empty\n  checkFill(board) {\n    for (var x = this.x0; x < this.x1; x++) {\n      for (var y = this.y0; y < this.y1; y++) {\n        if (board[y][x].type < 1) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // Clear the cells this TargetBlock covers and set its cleared flag to True\n  // TODO: Is it better to have this method in CoreState or TargetBlock?\n  clear(board, fillCell) {\n    for (var x = this.x0; x < this.x1; x++) {\n      for (var y = this.y0; y < this.y1; y++) {\n        board[y][x] = fillCell();\n      }\n    }\n    this.isCleared = true;\n  }\n}\nexport default TargetBlock;","map":{"version":3,"names":["DEFAULT_TICKS_TO_GROWTH","TargetBlock","constructor","props","x0","y0","x1","y1","coreState","boardSize","ticksToGrowth","ticksLeft","isGameOver","isFilled","isCleared","update","checkFill","board","grow","x","y","type","clear","fillCell"],"sources":["/Users/joeyzhu/code/Pentaquad/src/components/game/coreState/TargetBlock.js"],"sourcesContent":["const DEFAULT_TICKS_TO_GROWTH = 4\n\n// The primary objective of this game is not to fill up lines but to fill up rectangle-shaped TargetBlocks,\n// which grow over time and end the game once they exceed the bounds of the board. \nclass TargetBlock {\n    constructor(props) {\n        [this.x0, this.y0, this.x1, this.y1] = [props.x0, props.y0, props.x1, props.y1]\n        this.coreState = props.coreState\n        this.boardSize = props.coreState.boardSize\n        this.ticksToGrowth = props.ticksToGrowth ? props.ticksToGrowth : DEFAULT_TICKS_TO_GROWTH\n        this.ticksLeft = this.ticksToGrowth\n        this.isGameOver = false\n        this.isFilled = false\n        this.isCleared = false\n    }\n\n    // To be called once each time the coreState updates\n    update() {\n        if (this.checkFill(this.coreState.board))\n        this.ticksLeft -= 1\n        if (this.ticksLeft == 0) {\n            this.ticksLeft = this.ticksToGrowth\n            this.grow()\n        }\n    }\n    \n    // Extend the corners out by one cell. If any corner leaves the bounds of the game's board, GameOver flag goes up.\n    grow() {\n        this.x0 -= 1\n        this.y0 -= 1\n        this.x1 += 1\n        this.y1 += 1\n\n        if (this.x0 < 0 || this.y0 < 0 || this.x1 >= this.boardSize || this.y1 >= this.boardSize) {\n            this.isGameOver = true\n        }\n    }\n\n    // Check that every spot covered by this TargetBlock is \"filled\" with a Cell of type > 0, signifying that \n    // it is not empty\n    checkFill(board) {\n        for (var x = this.x0; x < this.x1; x++) {\n            for (var y = this.y0; y < this.y1; y++) {\n                if (board[y][x].type < 1) {\n                    return false\n                }\n            }\n        }\n        return true\n    }\n\n    // Clear the cells this TargetBlock covers and set its cleared flag to True\n    // TODO: Is it better to have this method in CoreState or TargetBlock?\n    clear(board, fillCell) {\n        for (var x = this.x0; x < this.x1; x++) {\n            for (var y = this.y0; y < this.y1; y++) {\n                board[y][x] = fillCell()\n            }\n        }\n        this.isCleared = true\n    }\n}\nexport default TargetBlock\n"],"mappings":"AAAA,MAAMA,uBAAuB,GAAG,CAAC;;AAEjC;AACA;AACA,MAAMC,WAAW,CAAC;EACdC,WAAWA,CAACC,KAAK,EAAE;IACf,CAAC,IAAI,CAACC,EAAE,EAAE,IAAI,CAACC,EAAE,EAAE,IAAI,CAACC,EAAE,EAAE,IAAI,CAACC,EAAE,CAAC,GAAG,CAACJ,KAAK,CAACC,EAAE,EAAED,KAAK,CAACE,EAAE,EAAEF,KAAK,CAACG,EAAE,EAAEH,KAAK,CAACI,EAAE,CAAC;IAC/E,IAAI,CAACC,SAAS,GAAGL,KAAK,CAACK,SAAS;IAChC,IAAI,CAACC,SAAS,GAAGN,KAAK,CAACK,SAAS,CAACC,SAAS;IAC1C,IAAI,CAACC,aAAa,GAAGP,KAAK,CAACO,aAAa,GAAGP,KAAK,CAACO,aAAa,GAAGV,uBAAuB;IACxF,IAAI,CAACW,SAAS,GAAG,IAAI,CAACD,aAAa;IACnC,IAAI,CAACE,UAAU,GAAG,KAAK;IACvB,IAAI,CAACC,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACC,SAAS,GAAG,KAAK;EAC1B;;EAEA;EACAC,MAAMA,CAAA,EAAG;IACL,IAAI,IAAI,CAACC,SAAS,CAAC,IAAI,CAACR,SAAS,CAACS,KAAK,CAAC,EACxC,IAAI,CAACN,SAAS,IAAI,CAAC;IACnB,IAAI,IAAI,CAACA,SAAS,IAAI,CAAC,EAAE;MACrB,IAAI,CAACA,SAAS,GAAG,IAAI,CAACD,aAAa;MACnC,IAAI,CAACQ,IAAI,EAAE;IACf;EACJ;;EAEA;EACAA,IAAIA,CAAA,EAAG;IACH,IAAI,CAACd,EAAE,IAAI,CAAC;IACZ,IAAI,CAACC,EAAE,IAAI,CAAC;IACZ,IAAI,CAACC,EAAE,IAAI,CAAC;IACZ,IAAI,CAACC,EAAE,IAAI,CAAC;IAEZ,IAAI,IAAI,CAACH,EAAE,GAAG,CAAC,IAAI,IAAI,CAACC,EAAE,GAAG,CAAC,IAAI,IAAI,CAACC,EAAE,IAAI,IAAI,CAACG,SAAS,IAAI,IAAI,CAACF,EAAE,IAAI,IAAI,CAACE,SAAS,EAAE;MACtF,IAAI,CAACG,UAAU,GAAG,IAAI;IAC1B;EACJ;;EAEA;EACA;EACAI,SAASA,CAACC,KAAK,EAAE;IACb,KAAK,IAAIE,CAAC,GAAG,IAAI,CAACf,EAAE,EAAEe,CAAC,GAAG,IAAI,CAACb,EAAE,EAAEa,CAAC,EAAE,EAAE;MACpC,KAAK,IAAIC,CAAC,GAAG,IAAI,CAACf,EAAE,EAAEe,CAAC,GAAG,IAAI,CAACb,EAAE,EAAEa,CAAC,EAAE,EAAE;QACpC,IAAIH,KAAK,CAACG,CAAC,CAAC,CAACD,CAAC,CAAC,CAACE,IAAI,GAAG,CAAC,EAAE;UACtB,OAAO,KAAK;QAChB;MACJ;IACJ;IACA,OAAO,IAAI;EACf;;EAEA;EACA;EACAC,KAAKA,CAACL,KAAK,EAAEM,QAAQ,EAAE;IACnB,KAAK,IAAIJ,CAAC,GAAG,IAAI,CAACf,EAAE,EAAEe,CAAC,GAAG,IAAI,CAACb,EAAE,EAAEa,CAAC,EAAE,EAAE;MACpC,KAAK,IAAIC,CAAC,GAAG,IAAI,CAACf,EAAE,EAAEe,CAAC,GAAG,IAAI,CAACb,EAAE,EAAEa,CAAC,EAAE,EAAE;QACpCH,KAAK,CAACG,CAAC,CAAC,CAACD,CAAC,CAAC,GAAGI,QAAQ,EAAE;MAC5B;IACJ;IACA,IAAI,CAACT,SAAS,GAAG,IAAI;EACzB;AACJ;AACA,eAAeb,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}