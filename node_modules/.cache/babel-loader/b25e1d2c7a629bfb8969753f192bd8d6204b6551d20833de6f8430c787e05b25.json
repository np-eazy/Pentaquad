{"ast":null,"code":"import { X, Y, G0, G1, MAX_GRID_BUFFER_SIZE, GRID_SIZE, MOVE_RATE, SWAPS_PER_FRAME, MAX_SWAP_RANGE, SWAP_FRACTION, FLUCTUATION_MAGNITUDE, VECOCITY_DECAY_RATE, DECAY_FACTOR, FLUCTUATION_RADIUS, VWEIGHT } from './graphic-utils.js';\nimport { Grid } from '../../utils/grid';\nimport { interpolate, randint, stoc } from '../../utils/functions';\nfunction clip(c) {\n  return [Math.min(Math.max(0, c[X]), GRID_SIZE[X] - 1), Math.min(Math.max(0, c[Y]), GRID_SIZE[Y] - 1)];\n}\n\n// Randomly sample from the entire grid\nfunction gridSample() {\n  return [randint(0, GRID_SIZE[X]), randint(0, GRID_SIZE[Y])];\n}\n\n// Sample from the axis-aligned square of length 2d+1 centered on x, y\nfunction boxSample(c, d) {\n  var dx = randint(0 - d, d + 1);\n  var dy = randint(0 - d, d + 1);\n  return clip([c[X] + dx, c[Y] + dy]);\n}\nfunction neighbor(c, d, v) {\n  return boxSample([c[X] + stoc(v[X]), c[Y] + stoc(v[Y])], d);\n}\nfunction transfer(grid, x1, y1, x2, y2, amt1, amt2) {\n  var cell1 = grid.getVal(x1, y1);\n  var cell2 = grid.getVal(x2, y2);\n  grid.setVal(x1, y1, interpolate(cell1, cell2, amt1));\n  grid.setVal(x2, y2, interpolate(cell1, cell2, amt2));\n}\nfunction step(mainGrid, maxSwapRange, swapFraction, xVelocityGrid, yVelocityGrid) {\n  var cellA = gridSample();\n  var cellB = neighbor(cellA, maxSwapRange, [xVelocityGrid.getVal(cellA[X], cellA[Y]), yVelocityGrid.getVal(cellA[X], cellA[Y])]);\n  if (cellB[X] == clip(cellB)[X] && cellB[Y] == clip(cellB)[Y]) {\n    // If the neighbor is valid, mix\n    transfer(mainGrid, cellA[X], cellA[Y], Math.floor(cellB[X]), Math.floor(cellB[Y]), swapFraction, swapFraction);\n  } else {\n    // Else, just drain\n    mainGrid.setVal(cellA[X], cellA[Y], mainGrid.getVal(cellA[X], cellA[Y]) * (1 - swapFraction));\n  }\n}\nfunction emptyGrid() {\n  return new Grid(GRID_SIZE[X], GRID_SIZE[Y]);\n}\nconst GameState = class {\n  constructor(_ref) {\n    let {} = _ref;\n    this.timer = 0;\n    this.smoothGrid = emptyGrid();\n    this.totalGrid = emptyGrid();\n    this.gridStream = [emptyGrid()];\n    this.currGridBufferSize = 1;\n    this.canvasSize = [G1[X] - G0[X], G1[Y] - G0[Y]];\n    this.ticks = 0;\n    this.mainGrid = emptyGrid();\n    this.vxGrid = emptyGrid();\n    this.vyGrid = emptyGrid();\n  }\n  addGridFrame(newGrid) {\n    // Add to the total grid\n    this.totalGrid.add(newGrid);\n    if (this.currGridBufferSize == MAX_GRID_BUFFER_SIZE) {\n      // If buffer is full, take out bottom of stream and set values to incoming grid\n      // And recalculate sliding total\n      var last = this.gridStream.shift();\n      this.totalGrid.subtract(last);\n      newGrid.copyTo(last);\n      this.gridStream.push(last);\n    } else {\n      // If buffer isn't full, add a copy of current and up counter\n      var newArr = emptyGrid();\n      newGrid.copyTo(newArr);\n      this.gridStream.push(newArr);\n      this.currGridBufferSize++;\n    }\n    this.smoothGrid.interpolate(this.totalGrid.createScale(1 / this.currGridBufferSize), MOVE_RATE);\n  }\n  pull(grid, center, target, range) {\n    center[X] = Math.floor(center[X]);\n    center[Y] = Math.floor(center[Y]);\n    var ax = Math.max(0, center[X] - range);\n    var bx = Math.min(grid.xSize - 1, center[X] + range + 1);\n    var ay = Math.max(0, center[Y] - range);\n    var by = Math.min(grid.ySize - 1, center[Y] + range + 1);\n    for (var x = ax; x <= bx; x++) {\n      for (var y = ay; y <= by; y++) {\n        var dx = x - center[X];\n        var dy = y - center[Y];\n        var r2 = dx * dx + dy * dy;\n        grid.setVal(x, y, interpolate(grid.getVal(x, y), target, FLUCTUATION_MAGNITUDE / (r2 + 1)));\n      }\n    }\n  }\n  update(increment) {\n    // addFrame(mouse);\n    this.addGridFrame(this.mainGrid);\n\n    // Run a number of Stochastic diffusion/flow iterations\n    for (var i = 0; i < SWAPS_PER_FRAME; i++) {\n      step(this.mainGrid, MAX_SWAP_RANGE, SWAP_FRACTION, this.vxGrid, this.vyGrid);\n    }\n    this.mainGrid.scale(DECAY_FACTOR);\n    this.vxGrid.scale(VECOCITY_DECAY_RATE);\n    this.vyGrid.scale(VECOCITY_DECAY_RATE);\n    if (this.timer % 2 == 0) {\n      var fx = randint(0, GRID_SIZE[X] - 1);\n      var fy = randint(0, GRID_SIZE[Y] - 1);\n      var vx = (Math.random() - 0.5) * 5;\n      var vy = (Math.random() - 0.5) * 5;\n      var size = Math.random() * 15;\n      var dx = (Math.random() - 0.5) * 5;\n      var dy = (Math.random() - 0.5) * 5;\n\n      //this.mainGrid[fy][fx] += 0.5 * Math.random();\n      this.pull(this.mainGrid, [fx, fy], size, FLUCTUATION_RADIUS);\n      this.pull(this.vxGrid, [fx, fy], -vx * VWEIGHT, FLUCTUATION_RADIUS);\n      this.pull(this.vyGrid, [fx, fy], -vy * VWEIGHT, FLUCTUATION_RADIUS);\n      fx += dx * 2;\n      fy += dy * 2;\n      var f = clip([fx, fy]);\n      fx = f[X];\n      fy = f[Y];\n\n      //this.mainGrid[fy][fx] += 0.5 * Math.random();\n      this.pull(this.mainGrid, [fx, fy], -size, FLUCTUATION_RADIUS);\n      this.pull(this.vxGrid, [fx, fy], vx * VWEIGHT, FLUCTUATION_RADIUS);\n      this.pull(this.vyGrid, [fx, fy], vy * VWEIGHT, FLUCTUATION_RADIUS);\n    }\n    this.timer++;\n    return this;\n  }\n  executeAction(action) {\n    console.log(key);\n    return this;\n  }\n};\nexport default GameState;","map":{"version":3,"names":["X","Y","G0","G1","MAX_GRID_BUFFER_SIZE","GRID_SIZE","MOVE_RATE","SWAPS_PER_FRAME","MAX_SWAP_RANGE","SWAP_FRACTION","FLUCTUATION_MAGNITUDE","VECOCITY_DECAY_RATE","DECAY_FACTOR","FLUCTUATION_RADIUS","VWEIGHT","Grid","interpolate","randint","stoc","clip","c","Math","min","max","gridSample","boxSample","d","dx","dy","neighbor","v","transfer","grid","x1","y1","x2","y2","amt1","amt2","cell1","getVal","cell2","setVal","step","mainGrid","maxSwapRange","swapFraction","xVelocityGrid","yVelocityGrid","cellA","cellB","floor","emptyGrid","GameState","constructor","_ref","timer","smoothGrid","totalGrid","gridStream","currGridBufferSize","canvasSize","ticks","vxGrid","vyGrid","addGridFrame","newGrid","add","last","shift","subtract","copyTo","push","newArr","createScale","pull","center","target","range","ax","bx","xSize","ay","by","ySize","x","y","r2","update","increment","i","scale","fx","fy","vx","random","vy","size","f","executeAction","action","console","log","key"],"sources":["/Users/joeyzhu/code/visuals/pentaquad/src/components/game/GameState.js"],"sourcesContent":["import {X, Y, G0, G1, MAX_GRID_BUFFER_SIZE, GRID_SIZE,\n    MOVE_RATE, SWAPS_PER_FRAME, MAX_SWAP_RANGE, SWAP_FRACTION, FLUCTUATION_MAGNITUDE,\n    VECOCITY_DECAY_RATE, DECAY_FACTOR, FLUCTUATION_RADIUS, VWEIGHT} from './graphic-utils.js';\n\nimport {Grid} from '../../utils/grid';\nimport {interpolate, randint, stoc} from '../../utils/functions';\n\n\nfunction clip(c) {\n    return [Math.min(Math.max(0, c[X]), GRID_SIZE[X] - 1), Math.min(Math.max(0, c[Y]), GRID_SIZE[Y] - 1)];\n}\n\n// Randomly sample from the entire grid\nfunction gridSample() {\n    return [randint(0, GRID_SIZE[X]), randint(0, GRID_SIZE[Y])];\n}\n\n// Sample from the axis-aligned square of length 2d+1 centered on x, y\nfunction boxSample(c, d) {\n    var dx = randint(0 - d, d + 1);\n    var dy = randint(0 - d, d + 1);\n    return clip([c[X] + dx, c[Y] + dy]);\n}\n\nfunction neighbor(c, d, v) {\n    return boxSample([c[X] + stoc(v[X]), c[Y] + stoc(v[Y])], d);\n}\n\nfunction transfer(grid, x1, y1, x2, y2, amt1, amt2) {\n    var cell1 = grid.getVal(x1, y1);\n    var cell2 = grid.getVal(x2, y2);\n\n    grid.setVal(x1, y1, \n        interpolate(cell1, cell2, \n            amt1));\n    grid.setVal(x2, y2, \n        interpolate(cell1, cell2, \n            amt2));\n}\n\n\nfunction step(mainGrid, maxSwapRange, swapFraction, xVelocityGrid, yVelocityGrid) {\n    var cellA = gridSample();\n    var cellB = neighbor(cellA, maxSwapRange, \n        [xVelocityGrid.getVal(cellA[X], cellA[Y]), yVelocityGrid.getVal(cellA[X], cellA[Y])]);\n    if (cellB[X] == clip(cellB)[X] && cellB[Y] == clip(cellB)[Y]) {\n        // If the neighbor is valid, mix\n        transfer(\n            mainGrid, \n            cellA[X], cellA[Y], \n            Math.floor(cellB[X]), Math.floor(cellB[Y]), \n            swapFraction, swapFraction);\n    } else {\n        // Else, just drain\n        mainGrid.setVal(cellA[X], cellA[Y], \n            mainGrid.getVal(cellA[X], cellA[Y]) * (1 - swapFraction));\n    }\n}\n\nfunction emptyGrid() {\n    return new Grid(GRID_SIZE[X], GRID_SIZE[Y]);\n}\n\nconst GameState = class {\n    constructor ({}) {\n        this.timer = 0;\n        this.smoothGrid = emptyGrid();\n        this.totalGrid = emptyGrid();\n        this.gridStream = [emptyGrid()];\n\n        this.currGridBufferSize = 1;\n        this.canvasSize = [G1[X] - G0[X], G1[Y] - G0[Y]];\n        this.ticks = 0;\n\n        this.mainGrid = emptyGrid();\n        this.vxGrid = emptyGrid();\n        this.vyGrid = emptyGrid();\n    }\n\n    addGridFrame(newGrid) {\n        // Add to the total grid\n        this.totalGrid.add(newGrid);\n        \n        if (this.currGridBufferSize == MAX_GRID_BUFFER_SIZE) {\n            // If buffer is full, take out bottom of stream and set values to incoming grid\n            // And recalculate sliding total\n            var last = this.gridStream.shift();\n            this.totalGrid.subtract(last);\n            newGrid.copyTo(last);\n            this.gridStream.push(last);\n\n        } else {\n            // If buffer isn't full, add a copy of current and up counter\n            var newArr = emptyGrid();\n            newGrid.copyTo(newArr);\n            this.gridStream.push(newArr);\n            this.currGridBufferSize++;\n        }\n        \n        this.smoothGrid.interpolate(\n            this.totalGrid.createScale(1 / this.currGridBufferSize),\n            MOVE_RATE\n        );\n    }\n\n    pull(grid, center, target, range) {\n        center[X] = Math.floor(center[X]);\n        center[Y] = Math.floor(center[Y]);\n        var ax = Math.max(0, center[X] - range);\n        var bx = Math.min(grid.xSize - 1, (center[X] + range) + 1);\n        var ay = Math.max(0, center[Y] - range);\n        var by = Math.min(grid.ySize - 1, (center[Y] + range) + 1);\n        for (var x = ax; x <= bx; x++) {\n            for (var y = ay; y <= by; y++) {\n                var dx = x - center[X];\n                var dy = y - center[Y];\n                var r2 = dx * dx + dy * dy;\n                grid.setVal(x, y, \n                    interpolate(grid.getVal(x, y), target, \n                        FLUCTUATION_MAGNITUDE / (r2 + 1)\n                    )\n                );\n            }\n        }\n    }\n\n    update(increment) {\n        // addFrame(mouse);\n        this.addGridFrame(this.mainGrid);\n\n        // Run a number of Stochastic diffusion/flow iterations\n        for (var i = 0; i < SWAPS_PER_FRAME; i++) {\n            step(this.mainGrid, MAX_SWAP_RANGE, SWAP_FRACTION, this.vxGrid, this.vyGrid);\n        }\n\n        this.mainGrid.scale(DECAY_FACTOR);\n        this.vxGrid.scale(VECOCITY_DECAY_RATE);\n        this.vyGrid.scale(VECOCITY_DECAY_RATE);\n\n        if (this.timer % 2 == 0) {\n            var fx = randint(0, GRID_SIZE[X] - 1);\n            var fy = randint(0, GRID_SIZE[Y] - 1);\n\n            var vx = (Math.random() - 0.5) * 5;\n            var vy = (Math.random() - 0.5) * 5;\n            var size = Math.random() * 15;\n\n            var dx = (Math.random() - 0.5) * 5;\n            var dy = (Math.random() - 0.5) * 5;\n\n            //this.mainGrid[fy][fx] += 0.5 * Math.random();\n            this.pull(this.mainGrid, [fx, fy], size, FLUCTUATION_RADIUS);\n            this.pull(this.vxGrid, [fx, fy], -vx * VWEIGHT, FLUCTUATION_RADIUS);\n            this.pull(this.vyGrid, [fx, fy], -vy * VWEIGHT, FLUCTUATION_RADIUS);\n            \n            fx += dx * 2;\n            fy += dy * 2;\n            var f = clip([fx, fy]);\n            fx = f[X];\n            fy = f[Y];\n\n            //this.mainGrid[fy][fx] += 0.5 * Math.random();\n            this.pull(this.mainGrid, [fx, fy], -size, FLUCTUATION_RADIUS);\n            this.pull(this.vxGrid, [fx, fy], vx * VWEIGHT, FLUCTUATION_RADIUS);\n            this.pull(this.vyGrid, [fx, fy], vy * VWEIGHT, FLUCTUATION_RADIUS);\n        }\n        this.timer++;\n        return this;\n    }\n\n    executeAction(action) {\n        console.log(key);\n        return this;\n    }\n}\n\nexport default GameState;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}