{"ast":null,"code":"import { X, Y, GRID_SIZE, T, G0, G1, BASE, RAD } from './graphic-utils.js';\nfunction drawRect(canvas, x1, y1, x2, y2) {\n  var canvas = c.getContext(\"2d\");\n  canvas.beginPath();\n  canvas.rect(20, 20, 150, 100);\n  canvas.stroke();\n}\nconst GameGraphics = props => {\n  function render(canvas, grid, glow) {\n    var center;\n    var length;\n    for (var y = 0; y < GRID_SIZE[Y]; y++) {\n      for (var x = 10; x < GRID_SIZE[X] - 5; x++) {\n        length = BASE + RAD * grid.getVal(x, y) * 2;\n        center = localToGlobal([x + 0.5, y + 0.5]);\n\n        // Get grid colors\n        var r = 0.4 + 0.006 * (x + y) + 0.05 * Math.sin(props.gameState.timer * 0.24 / T);\n        var g = 0.3 + 0.002 * (x - y) + 0.04 * Math.cos(props.gameState.timer * 0.48 / T);\n        var b = 0.45 - 0.006 * (x / 2 + y) - 0.1 * Math.sin(props.gameState.timer * 0.89 / T);\n\n        // Invert if negative\n        if (grid.getVal(x, y) < 0) {\n          r = 1 - r;\n          g = 1 - g;\n          b = 1 - b;\n        }\n\n        // Render checkerboard of crosses\n        if ((x + y) % 2 == 0) {\n          // Linear dodge for more engaging colors\n          var blur = Math.min(1, Math.max(0, glow - (y - 25) / 5));\n          r = clip1d(r * (1 + 2 * blur * grid.getVal(x, y) * grid.getVal(x, y)));\n          g = clip1d(g * (1 + 1.5 * blur * grid.getVal(x, y) * grid.getVal(x, y)));\n          b = clip1d(b * (1 + 0.75 * blur * grid.getVal(x, y) * grid.getVal(x, y)));\n          var hex = rgbToHex(r, g, b);\n          drawDiagCross(canvas, [center[X], center[Y]], Math.min(10, Math.abs(length) * 1.3), hex);\n        }\n      }\n    }\n  }\n  var canv = document.getElementById(\"gameGraphics\");\n  var ctx = canv != null ? canv.getContext('2d') : null;\n  if (ctx != null && props.gameState != undefined) {\n    ctx.clearRect(G0[X], G0[Y], G1[X], G1[Y]);\n    render(ctx, props.gameState.smoothGrid, 8);\n  }\n};\n_c = GameGraphics;\nexport default GameGraphics;\nvar _c;\n$RefreshReg$(_c, \"GameGraphics\");","map":{"version":3,"names":["X","Y","GRID_SIZE","T","G0","G1","BASE","RAD","drawRect","canvas","x1","y1","x2","y2","c","getContext","beginPath","rect","stroke","GameGraphics","props","render","grid","glow","center","length","y","x","getVal","localToGlobal","r","Math","sin","gameState","timer","g","cos","b","blur","min","max","clip1d","hex","rgbToHex","drawDiagCross","abs","canv","document","getElementById","ctx","undefined","clearRect","smoothGrid","_c","$RefreshReg$"],"sources":["/Users/joeyzhu/code/visuals/pentaquad/src/components/game/GameGraphics.js"],"sourcesContent":["import {X, Y, GRID_SIZE, T, G0, G1, BASE, RAD} from './graphic-utils.js';\n\nfunction drawRect(canvas, x1, y1, x2, y2) {\n    var canvas = c.getContext(\"2d\");\n    canvas.beginPath();\n    canvas.rect(20, 20, 150, 100);\n    canvas.stroke();\n}\n\nconst GameGraphics = (props) => {\n    function render(canvas, grid, glow) {\n        var center;\n        var length;\n        for (var y = 0; y < GRID_SIZE[Y]; y++) {\n            for (var x = 10; x < GRID_SIZE[X]-5; x++) {\n                length = BASE + RAD * (grid.getVal(x, y)) * 2;\n                center = localToGlobal([x + 0.5, y + 0.5]);\n                \n                // Get grid colors\n                var r = 0.4 + 0.006 * (x + y) + 0.05 * Math.sin(props.gameState.timer * 0.24 / T);\n                var g = 0.3 + 0.002 * (x - y) + 0.04 * Math.cos(props.gameState.timer * 0.48 / T );\n                var b = 0.45 - 0.006 * (x / 2 + y) - 0.1 * Math.sin(props.gameState.timer * 0.89 / T);\n                \n                // Invert if negative\n                if (grid.getVal(x, y) < 0) {\n                    r = 1 - r;\n                    g = 1 - g;\n                    b = 1 - b;\n                }\n                \n                // Render checkerboard of crosses\n                if ((x + y) % 2 == 0) {\n                    // Linear dodge for more engaging colors\n                    var blur = Math.min(1, Math.max(0, glow - (y-25)/5));\n                    r = clip1d(r * (1 + 2 * blur * grid.getVal(x, y) * grid.getVal(x, y)));\n                    g = clip1d(g * (1 + 1.5 * blur * grid.getVal(x, y) * grid.getVal(x, y)));\n                    b = clip1d(b * (1 + 0.75 * blur * grid.getVal(x, y) * grid.getVal(x, y)));\n                    \n                    var hex = rgbToHex(r, g, b);\n                    drawDiagCross(canvas, [center[X], center[Y]], Math.min(10, Math.abs(length) * 1.3), hex);\n                }\n            }\n        }\n    }\n\n    var canv = document.getElementById(\"gameGraphics\");\n    var ctx = canv != null ? canv.getContext('2d') : null;\n\n    if (ctx != null && props.gameState != undefined) {\n        ctx.clearRect(G0[X], G0[Y], G1[X], G1[Y]);\n        render(ctx, props.gameState.smoothGrid, 8);\n    }\n};\n\nexport default GameGraphics;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}