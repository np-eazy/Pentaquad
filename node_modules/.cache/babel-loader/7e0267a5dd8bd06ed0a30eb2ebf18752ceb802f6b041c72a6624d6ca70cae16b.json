{"ast":null,"code":"function drawRect(canvas, x, y, xSize, ySize, color) {\n  canvas.fillStyle = color;\n  canvas.fillRect(x, y, xSize, ySize);\n}\nfunction outlineRect(canvas, x, y, xSize, ySize, color) {\n  canvas.strokeStyle = color;\n  canvas.beginPath();\n  canvas.strokeRect(x, y, xSize, ySize);\n  canvas.closePath();\n}\nconst GameGraphics = props => {\n  function render(canvas, board) {\n    // Fill in cells from the coreState board\n    var [xSize, ySize] = [board[0].length, board.length];\n    var [xCellSize, yCellSize] = [props.windowSize / xSize, props.windowSize / ySize];\n    for (var y = 0; y < ySize; y++) {\n      for (var x = 0; x < xSize; x++) {\n        if (board[y][x].type > 0) {\n          drawRect(canvas, x * xCellSize, y * yCellSize, xCellSize, yCellSize, board[y][x].props.parent.color.getHex());\n        }\n      }\n    }\n\n    // Fill in cells from the coreState current piece.\n    var [x, y] = [0, 0];\n    var piece = props.gameState.coreState.currPiece;\n    if (piece != null) {\n      // Fill in the hitboxes to debug collision detection.\n      // Fill in the actual cell\n      for (const cell of piece.cells) {\n        [x, y] = [cell[1][0] + piece.cx, cell[1][1] + piece.cy];\n        drawRect(canvas, x * xCellSize, y * yCellSize, xCellSize, yCellSize, piece.color.getHex());\n      }\n    }\n\n    // Draw outlines of TargetBlocks\n    for (var t of props.gameState.coreState.targetBlocks) {\n      outlineRect(canvas, t.x0 * xCellSize, t.y0 * yCellSize, (t.x1 - t.x0) * xCellSize, (t.y1 - t.y0) * yCellSize, \"#000000\");\n    }\n  }\n\n  // Canvas and context wiring\n  var canv = document.getElementById(\"gameGraphics\");\n  var ctx = canv != null ? canv.getContext('2d') : null;\n  if (ctx != null && props.gameState != undefined) {\n    ctx.clearRect(0, 0, props.windowSize, props.windowSize);\n    render(ctx, props.gameState.coreState.board);\n  }\n};\n_c = GameGraphics;\nexport default GameGraphics;\nvar _c;\n$RefreshReg$(_c, \"GameGraphics\");","map":{"version":3,"names":["drawRect","canvas","x","y","xSize","ySize","color","fillStyle","fillRect","outlineRect","strokeStyle","beginPath","strokeRect","closePath","GameGraphics","props","render","board","length","xCellSize","yCellSize","windowSize","type","parent","getHex","piece","gameState","coreState","currPiece","cell","cells","cx","cy","t","targetBlocks","x0","y0","x1","y1","canv","document","getElementById","ctx","getContext","undefined","clearRect","_c","$RefreshReg$"],"sources":["/Users/joeyzhu/code/Pentaquad/src/components/game/graphics/GameGraphics.js"],"sourcesContent":["function drawRect(canvas, x, y, xSize, ySize, color) {\n    canvas.fillStyle = color\n    canvas.fillRect(x, y, xSize, ySize)\n}\n\nfunction outlineRect(canvas, x, y, xSize, ySize, color) {\n    canvas.strokeStyle = color\n    canvas.beginPath()\n    canvas.strokeRect(x, y, xSize, ySize)\n    canvas.closePath()\n}\n\nconst GameGraphics = (props) => {\n    function render(canvas, board) {\n        // Fill in cells from the coreState board\n        var [xSize, ySize] = [board[0].length, board.length]\n        var [xCellSize, yCellSize] = [props.windowSize / xSize, props.windowSize / ySize]\n        for (var y = 0; y < ySize; y++) {\n            for (var x = 0; x < xSize; x++) {\n                if (board[y][x].type > 0) {\n                    drawRect(canvas, x * xCellSize, y * yCellSize, xCellSize, yCellSize, board[y][x].props.parent.color.getHex());\n                }\n            }\n        }\n\n        // Fill in cells from the coreState current piece.\n        var [x, y] = [0, 0]\n        var piece = props.gameState.coreState.currPiece\n        if (piece != null) {\n            // Fill in the hitboxes to debug collision detection.\n            // Fill in the actual cell\n            for (const cell of piece.cells) {\n                [x, y] = [cell[1][0] + piece.cx, cell[1][1] + piece.cy]\n                drawRect(canvas, x * xCellSize, y * yCellSize, xCellSize, yCellSize, piece.color.getHex());\n            }\n        }\n\n        // Draw outlines of TargetBlocks\n        for (var t of props.gameState.coreState.targetBlocks) {\n            outlineRect(canvas, t.x0 * xCellSize, t.y0 * yCellSize, (t.x1 - t.x0) * xCellSize, (t.y1 - t.y0) * yCellSize, \"#000000\")\n        }\n    }\n\n    // Canvas and context wiring\n    var canv = document.getElementById(\"gameGraphics\");\n    var ctx = canv != null ? canv.getContext('2d') : null;\n    if (ctx != null && props.gameState != undefined) {\n        ctx.clearRect(0, 0, props.windowSize, props.windowSize);\n        render(ctx, props.gameState.coreState.board);\n    }\n};\n\nexport default GameGraphics;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}