{"ast":null,"code":"import Cell from \"./Cell\";\nimport Piece from \"./Piece\";\nimport { randint, getPID, Direction, DXN } from \"./Utils\";\nimport { ActionType } from \"./GameAction\";\n\n// Number of cells in each piece.\nconst PIECE_SIZE = 5;\n// The distance from the boundary that each piece \nconst SPAWN_OFFSET = 2;\n// Extend edge boundaries a bit further out of the grid to make sure\n// pieces spawning on the edge can still hit the ground.\nconst BOUNDARY_MARGIN = 4;\n\n// The most essential level of state in the game. Each update() call either\n// moves an existing block, or places it and creates a new block after shifting\n// gravity. \n\nconst CoreState = class {\n  constructor(props) {\n    // The GameState's main controller\n    this.controller = props.controller;\n    // A timer that increments once each update; updates should only be called from a higher-level state which is allowed to pause\n    // or speed up the game, whether from a menu option or an in-game mechanism.\n    this.timer = 0;\n    // The dimension of the square board on which this game takes place.\n    this.boardSize = props.boardSize;\n    // The default \"empty\" value of this grid: a type-0 Cell with no props\n    this.emptyValue = () => new Cell(0, {});\n    // The main board on which everything happens\n    this.board = [...Array(props.boardSize)].map(e => Array(props.boardSize).fill(this.emptyValue()));\n    // All sets of (x, y) pairs checking each other for collisions will have a unique PID dependent on a 3rd parameter\n    // describing the max size of the PID group, in order for uniqueness to work.\n    this.pidSize = (props.boardSize + SPAWN_OFFSET * 2) * 2;\n    // The direction in which the piece moves, and in which the board moves after a line is cleared.\n    this.gravity = new Direction(DXN.DOWN);\n    // Flag for placing a block\n    this.placeBlock = true;\n    // The GameState's current unplaced piece\n    this.currPiece = null;\n\n    // Create 4 different sets to check if a boundary has been hit\n    var [xSize, ySize] = [props.boardSize, props.boardSize];\n    var pid;\n    this.boundarySets = [];\n    for (var i = 0; i < 4; i++) {\n      this.boundarySets.push(new Map());\n    }\n    for (var i = -BOUNDARY_MARGIN; i < ySize + BOUNDARY_MARGIN; i++) {\n      pid = getPID(xSize, i, this.pidSize);\n      this.boundarySets[DXN.RIGHT].set(pid, [xSize, i]);\n      pid = getPID(i, -1, this.pidSize);\n      this.boundarySets[DXN.UP].set(pid, [i, -1]);\n      pid = getPID(-1, i, this.pidSize);\n      this.boundarySets[DXN.LEFT].set(pid, [-1, i]);\n      pid = getPID(i, ySize, this.pidSize);\n      this.boundarySets[DXN.DOWN].set(pid, [i, ySize]);\n    }\n  }\n\n  // TODO: Actually design balanced game mechanisms. The current code demonstrates the\n  // core rules of the game but is not very playable at all, nor does it have good objectives.\n  update() {\n    if (this.placeBlock) {\n      this.placeBlock = false;\n      var [x, y] = [0, 0];\n\n      // Place the current piece\n\n      // Set the position and gravity with which to create a new piece\n      this.gravity.turnLeft(1);\n      this.createNewPiece();\n\n      // Check for filled lines\n      var angle = this.currPiece.dxn.angle;\n      if (angle % 2 == 0) {\n        for (var x = 0; x < this.boardSize; x++) {\n          var count = 0;\n          for (var y = 0; y < this.boardSize; y++) {\n            if (this.board[y][x].type > 0) {\n              count += 1;\n            }\n          }\n          // Horizontally shift the left or the right of the cleared line\n          if (count >= this.boardSize / 2) {\n            if (angle % 4 == 2) {\n              for (var j = 0; j < x; j++) {\n                i = x - j - 1;\n                for (var y_ = 0; y_ < this.boardSize; y_++) {\n                  this.board[y_][i + 1] = this.board[y_][i];\n                }\n              }\n              for (var y_ = 0; y_ < this.boardSize; y_++) {\n                this.board[y_][this.boardSize - 1] = new Cell(0, {});\n              }\n            } else {\n              for (var i = x + 1; i < this.boardSize; i++) {\n                for (var y_ = 0; y_ < this.boardSize; y_++) {\n                  this.board[y_][i - 1] = this.board[y_][i];\n                }\n              }\n              for (var y_ = 0; y_ < this.boardSize; y_++) {\n                this.board[y_][0] = new Cell(0, {});\n              }\n            }\n          }\n        }\n      } else {\n        for (var y = 0; y < this.boardSize; y++) {\n          var count = 0;\n          for (var x = 0; x < this.boardSize; x++) {\n            if (this.board[y][x].type > 0) {\n              count += 1;\n            }\n          }\n          // Horizontally shift the left or the right of the cleared line\n          if (count >= this.boardSize / 2) {\n            if (angle % 4 == 1) {\n              for (var j = 0; j < y; j++) {\n                i = y - j - 1;\n                for (var x_ = 0; x_ < this.boardSize; x_++) {\n                  this.board[i + 1][x_] = this.board[i][x_];\n                }\n              }\n              for (var x_ = 0; x_ < this.boardSize; x_++) {\n                this.board[0][x_] = new Cell(0, {});\n              }\n            } else {\n              for (var i = y + 1; j < this.boardSize; i++) {\n                for (var x_ = 0; x_ < this.boardSize; x_++) {\n                  this.board[i - 1][x_] = this.board[i][x_];\n                }\n              }\n              for (var x_ = 0; x_ < this.boardSize; x_++) {\n                this.board[this.boardSize - 1][x_] = new Cell(0, {});\n              }\n            }\n            break;\n          }\n        }\n      }\n    } else {\n      if (this.currPiece) {\n        this.currPiece.idleMove();\n        if (this.currPiece.checkCollision(this.currPiece.dxn.angle, this.board, this.boundarySets)) {\n          this.placeBlock = true;\n        } else {\n          if (this.controller && !this.placeBlock) {\n            var action = this.controller.consumeAction();\n            if (action) {\n              this.executeAction(action);\n            }\n          }\n        }\n      }\n    }\n    this.timer += 1;\n    return this;\n  }\n\n  // Change the CoreState's grid values based on where the current piece is.\n  placeCurrentPiece() {\n    if (this.currPiece != null) {\n      for (const cell of this.currPiece.cells) {\n        [x, y] = [cell[1][0] + this.currPiece.cx, cell[1][1] + this.currPiece.cy];\n        if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize) {\n          this.board[y][x] = this.currPiece.createCell();\n        }\n      }\n    }\n  }\n\n  // Create a new piece based on this CoreState's gravity, at a random location.\n  createNewPiece() {\n    var [x, y] = [0, 0];\n    var r = randint(-SPAWN_OFFSET, this.boardSize + SPAWN_OFFSET);\n    if (this.gravity.angle == DXN.RIGHT) {\n      [x, y] = [-SPAWN_OFFSET, r];\n    } else if (this.gravity.angle == DXN.UP) {\n      [x, y] = [r, SPAWN_OFFSET + this.boardSize];\n    } else if (this.gravity.angle == DXN.LEFT) {\n      [x, y] = [SPAWN_OFFSET + this.boardSize, r];\n    } else if (this.gravity.angle == DXN.DOWN) {\n      [x, y] = [r, -SPAWN_OFFSET];\n    }\n    // Create the new piece\n    this.currPiece = new Piece({\n      center_x: x,\n      center_y: y,\n      angle: this.gravity.angle,\n      pieceSize: PIECE_SIZE,\n      pidSize: this.pidSize\n    });\n  }\n\n  // TODO: Call this.currPiece.activeMove and check for the collision in both idle and active directions\n  executeAction(action) {\n    if (action.type == ActionType.MOVE) {\n      if (this.currPiece.checkCollision(action.props.angle, this.board, this.boundarySets)) {\n        this.placeBlock = true;\n      } else {\n        this.currPiece.activeMove(action.props.angle);\n        if (this.currPiece.checkCollision(this.currPiece.dxn.angle, this.board, this.boundarySets)) {\n          this.placeBlock = true;\n        }\n      }\n    } else if (action.type == ActionType.PLACE) {\n      this.placeBlock = true;\n    }\n    return this;\n  }\n};\nexport default CoreState;","map":{"version":3,"names":["Cell","Piece","randint","getPID","Direction","DXN","ActionType","PIECE_SIZE","SPAWN_OFFSET","BOUNDARY_MARGIN","CoreState","constructor","props","controller","timer","boardSize","emptyValue","board","Array","map","e","fill","pidSize","gravity","DOWN","placeBlock","currPiece","xSize","ySize","pid","boundarySets","i","push","Map","RIGHT","set","UP","LEFT","update","x","y","turnLeft","createNewPiece","angle","dxn","count","type","j","y_","x_","idleMove","checkCollision","action","consumeAction","executeAction","placeCurrentPiece","cell","cells","cx","cy","createCell","r","center_x","center_y","pieceSize","MOVE","activeMove","PLACE"],"sources":["/Users/joeyzhu/code/visuals/pentaquad/src/components/game/coreState/CoreState.js"],"sourcesContent":["import Cell from \"./Cell\"\nimport Piece from \"./Piece\"\nimport { randint, getPID, Direction, DXN } from \"./Utils\"\nimport { ActionType } from \"./GameAction\"\n\n// Number of cells in each piece.\nconst PIECE_SIZE = 5;\n// The distance from the boundary that each piece \nconst SPAWN_OFFSET = 2;\n// Extend edge boundaries a bit further out of the grid to make sure\n// pieces spawning on the edge can still hit the ground.\nconst BOUNDARY_MARGIN = 4;\n\n// The most essential level of state in the game. Each update() call either\n// moves an existing block, or places it and creates a new block after shifting\n// gravity. \n\nconst CoreState = class {\n    constructor (props) {\n        // The GameState's main controller\n        this.controller = props.controller;\n        // A timer that increments once each update; updates should only be called from a higher-level state which is allowed to pause\n        // or speed up the game, whether from a menu option or an in-game mechanism.\n        this.timer = 0;\n        // The dimension of the square board on which this game takes place.\n        this.boardSize = props.boardSize;\n        // The default \"empty\" value of this grid: a type-0 Cell with no props\n        this.emptyValue = () => new Cell(0, {}); \n        // The main board on which everything happens\n        this.board = [...Array(props.boardSize)].map(e => Array(props.boardSize).fill(this.emptyValue()));\n        // All sets of (x, y) pairs checking each other for collisions will have a unique PID dependent on a 3rd parameter\n        // describing the max size of the PID group, in order for uniqueness to work.\n        this.pidSize = (props.boardSize + SPAWN_OFFSET * 2) * 2;\n        // The direction in which the piece moves, and in which the board moves after a line is cleared.\n        this.gravity = new Direction(DXN.DOWN);\n        // Flag for placing a block\n        this.placeBlock = true;\n        // The GameState's current unplaced piece\n        this.currPiece = null;\n\n\n        // Create 4 different sets to check if a boundary has been hit\n        var [xSize, ySize] = [props.boardSize, props.boardSize]\n        var pid;\n        this.boundarySets = [];\n        for (var i = 0; i < 4; i++) {\n            this.boundarySets.push(new Map())\n        }\n        for (var i = -BOUNDARY_MARGIN; i < ySize + BOUNDARY_MARGIN; i++) {\n            pid = getPID(xSize, i, this.pidSize);\n            this.boundarySets[DXN.RIGHT].set(pid, [xSize, i])\n\n            pid = getPID(i, -1, this.pidSize);\n            this.boundarySets[DXN.UP].set(pid, [i, -1])\n\n            pid = getPID(-1, i, this.pidSize);\n            this.boundarySets[DXN.LEFT].set(pid, [-1, i])\n\n            pid = getPID(i, ySize, this.pidSize);\n            this.boundarySets[DXN.DOWN].set(pid, [i, ySize])\n        }\n    }\n\n    // TODO: Actually design balanced game mechanisms. The current code demonstrates the\n    // core rules of the game but is not very playable at all, nor does it have good objectives.\n    update() {\n        if (this.placeBlock) {\n            this.placeBlock = false;\n            var [x, y] = [0, 0]\n\n            // Place the current piece\n            \n\n            // Set the position and gravity with which to create a new piece\n            this.gravity.turnLeft(1);\n            this.createNewPiece();\n\n            // Check for filled lines\n            var angle = this.currPiece.dxn.angle\n            if (angle % 2 == 0) {\n                for (var x = 0; x < this.boardSize; x++) {\n                    var count = 0;\n                    for (var y = 0; y < this.boardSize; y++) {\n                        if (this.board[y][x].type > 0) {\n                            count += 1;\n                        }\n                    }\n                    // Horizontally shift the left or the right of the cleared line\n                    if (count >= this.boardSize / 2) {\n                        if (angle % 4 == 2) {\n                            for (var j = 0; j < x; j++) {\n                                i = x - j - 1\n                                for (var y_ = 0; y_ < this.boardSize; y_++) {\n                                    this.board[y_][i + 1] = this.board[y_][i]\n                                }\n                            }\n                            for (var y_ = 0; y_ < this.boardSize; y_++) {\n                                this.board[y_][this.boardSize - 1] = new Cell(0, {})\n                            }\n                        } else {\n                            for (var i = x + 1; i < this.boardSize; i++) {\n                                for (var y_ = 0; y_ < this.boardSize; y_++) {\n                                    this.board[y_][i - 1] = this.board[y_][i]\n                                }\n                            }\n                            for (var y_ = 0; y_ < this.boardSize; y_++) {\n                                this.board[y_][0] = new Cell(0, {})\n                            }\n                        }\n                    }\n                }\n            } else {\n                for (var y = 0; y < this.boardSize; y++) {\n                    var count = 0;\n                    for (var x = 0; x < this.boardSize; x++) {\n                        if (this.board[y][x].type > 0) {\n                            count += 1;\n                        }\n                    }\n                    // Horizontally shift the left or the right of the cleared line\n                    if (count >= this.boardSize / 2) {\n                        if (angle % 4 == 1) {\n                            for (var j = 0; j < y; j++) {\n                                i = y - j - 1\n                                for (var x_ = 0; x_ < this.boardSize; x_++) {\n                                    this.board[i + 1][x_] = this.board[i][x_]\n                                }\n                            }\n                            for (var x_ = 0; x_ < this.boardSize; x_++) {\n                                this.board[0][x_] = new Cell(0, {})\n                            }\n                        } else {\n                            for (var i = y + 1; j < this.boardSize; i++) {\n                                for (var x_ = 0; x_ < this.boardSize; x_++) {\n                                    this.board[i - 1][x_] = this.board[i][x_]\n                                }\n                            }\n                            for (var x_ = 0; x_ < this.boardSize; x_++) {\n                                this.board[this.boardSize - 1][x_] = new Cell(0, {})\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n        } else {\n            if (this.currPiece) {\n                this.currPiece.idleMove()\n                if (this.currPiece.checkCollision(this.currPiece.dxn.angle, this.board, this.boundarySets)) {\n                    this.placeBlock = true\n                } else {\n                    if (this.controller && !this.placeBlock) {\n                        var action = this.controller.consumeAction()\n                        if (action) {\n                            this.executeAction(action)\n                        }\n                    }\n                }\n            }\n        }\n        this.timer += 1\n        return this;\n    }\n\n    // Change the CoreState's grid values based on where the current piece is.\n    placeCurrentPiece() {\n        if (this.currPiece != null) {\n            for (const cell of this.currPiece.cells) {\n                [x, y] = [cell[1][0] + this.currPiece.cx, cell[1][1] + this.currPiece.cy]\n                if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize) {\n                    this.board[y][x] = this.currPiece.createCell()\n                }\n            }\n        }\n    }\n\n    // Create a new piece based on this CoreState's gravity, at a random location.\n    createNewPiece() {\n        var [x, y] = [0, 0]\n        var r = randint(-SPAWN_OFFSET, this.boardSize + SPAWN_OFFSET)\n        if (this.gravity.angle == DXN.RIGHT) {\n            [x, y] = [-SPAWN_OFFSET, r]\n        } else if (this.gravity.angle == DXN.UP) {\n            [x, y] = [r, SPAWN_OFFSET + this.boardSize]\n        } else if (this.gravity.angle == DXN.LEFT) {\n            [x, y] = [SPAWN_OFFSET + this.boardSize, r]\n        } else if (this.gravity.angle == DXN.DOWN) {\n            [x, y] = [r, -SPAWN_OFFSET]\n        }\n        // Create the new piece\n        this.currPiece = new Piece({\n            center_x: x,\n            center_y: y,\n            angle: this.gravity.angle,\n            pieceSize: PIECE_SIZE,\n            pidSize: this.pidSize,\n        })\n    }\n\n    // TODO: Call this.currPiece.activeMove and check for the collision in both idle and active directions\n    executeAction(action) {\n        if (action.type == ActionType.MOVE) {\n            if (this.currPiece.checkCollision(action.props.angle, this.board, this.boundarySets)) {\n                this.placeBlock = true\n            } else {\n                this.currPiece.activeMove(action.props.angle)\n                if (this.currPiece.checkCollision(this.currPiece.dxn.angle, this.board, this.boundarySets) ) {\n                    this.placeBlock = true\n                }\n            }\n        } else if (action.type == ActionType.PLACE) {\n            this.placeBlock = true\n        }\n        return this;\n    }\n}\n\nexport default CoreState;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}