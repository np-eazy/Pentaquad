{"ast":null,"code":"import { X, Y, GRID_SIZE, T, G0, G1, BASE, RAD } from './graphic-utils.js';\nimport { Color, rgbToHex } from \"../../utils/colors\";\nfunction drawRect(canvas, x, y, xSize, ySize, color) {\n  canvas.strokeStyle = color;\n  canvas.beginPath();\n  canvas.fillRect(x, y, xSize, ySize);\n  canvas.stroke();\n  canvas.closePath();\n}\nvar DEBUG = false;\nconst GameGraphics = props => {\n  function render(canvas, board) {\n    var [xSize, ySize] = [board[0].length, board.length];\n    var [xCellSize, yCellSize] = [props.windowSize / xSize, props.windowSize / ySize];\n    for (var y = 0; y < ySize; y++) {\n      for (var x = 0; x < xSize; x++) {\n        if (board[y][x].type > 0) {\n          var c = board[y][x].props.parent.color;\n          console.log(c);\n          drawRect(canvas, x * xCellSize, y * yCellSize, xCellSize, yCellSize, rgbToHex(c.red, c.green, c.blue));\n        }\n      }\n    }\n    var [x, y] = [0, 0];\n    var piece = props.gameState.currPiece;\n    if (piece != null) {\n      if (DEBUG) {\n        for (var i = 0; i < 4; i++) {\n          for (const cell of piece.collisionSets[i]) {\n            [x, y] = [cell[1][0] + piece.cx, cell[1][1] + piece.cy];\n            drawRect(canvas, x * xCellSize, y * yCellSize, xCellSize, yCellSize, \"#aaaaaa\");\n          }\n        }\n      }\n      for (const cell of piece.cells) {\n        [x, y] = [cell[1][0] + piece.cx, cell[1][1] + piece.cy];\n        drawRect(canvas, x * xCellSize, y * yCellSize, xCellSize, yCellSize, piece.color.getHex());\n      }\n    }\n  }\n  var canv = document.getElementById(\"gameGraphics\");\n  var ctx = canv != null ? canv.getContext('2d') : null;\n  if (ctx != null && props.gameState != undefined) {\n    ctx.clearRect(0, 0, props.windowSize, props.windowSize);\n    render(ctx, props.gameState.board);\n  }\n};\n_c = GameGraphics;\nexport default GameGraphics;\nvar _c;\n$RefreshReg$(_c, \"GameGraphics\");","map":{"version":3,"names":["X","Y","GRID_SIZE","T","G0","G1","BASE","RAD","Color","rgbToHex","drawRect","canvas","x","y","xSize","ySize","color","strokeStyle","beginPath","fillRect","stroke","closePath","DEBUG","GameGraphics","props","render","board","length","xCellSize","yCellSize","windowSize","type","c","parent","console","log","red","green","blue","piece","gameState","currPiece","i","cell","collisionSets","cx","cy","cells","getHex","canv","document","getElementById","ctx","getContext","undefined","clearRect","_c","$RefreshReg$"],"sources":["/Users/joeyzhu/code/visuals/pentaquad/src/components/game/GameGraphics.js"],"sourcesContent":["import {X, Y, GRID_SIZE, T, G0, G1, BASE, RAD} from './graphic-utils.js';\nimport { Color, rgbToHex } from \"../../utils/colors\";\n\nfunction drawRect(canvas, x, y, xSize, ySize, color) {\n    canvas.strokeStyle = color;\n    canvas.beginPath();\n    canvas.fillRect(x, y, xSize, ySize);\n    canvas.stroke();\n    canvas.closePath();\n}\nvar DEBUG = false;\n\nconst GameGraphics = (props) => {\n    function render(canvas, board) {\n        var [xSize, ySize] = [board[0].length, board.length]\n        var [xCellSize, yCellSize] = [props.windowSize / xSize, props.windowSize / ySize]\n        for (var y = 0; y < ySize; y++) {\n            for (var x = 0; x < xSize; x++) {\n                if (board[y][x].type > 0) {\n                    var c = board[y][x].props.parent.color\n                    console.log(c)\n                    drawRect(canvas, x * xCellSize, y * yCellSize, xCellSize, yCellSize, rgbToHex(c.red, c.green, c.blue));\n                }\n            }\n        }\n        var [x, y] = [0, 0]\n        var piece = props.gameState.currPiece\n        if (piece != null) {\n            if (DEBUG) {\n                for (var i = 0; i < 4; i++) {\n                    for (const cell of piece.collisionSets[i]) {\n                        [x, y] = [cell[1][0] + piece.cx, cell[1][1] + piece.cy]\n                        drawRect(canvas, x * xCellSize, y * yCellSize, xCellSize, yCellSize, \"#aaaaaa\");\n                    }\n                }\n            }\n        \n            for (const cell of piece.cells) {\n                [x, y] = [cell[1][0] + piece.cx, cell[1][1] + piece.cy]\n                drawRect(canvas, x * xCellSize, y * yCellSize, xCellSize, yCellSize, piece.color.getHex());\n            }\n        }\n    }\n\n    var canv = document.getElementById(\"gameGraphics\");\n    var ctx = canv != null ? canv.getContext('2d') : null;\n    \n    if (ctx != null && props.gameState != undefined) {\n        ctx.clearRect(0, 0, props.windowSize, props.windowSize);\n        render(ctx, props.gameState.board);\n    }\n};\n\nexport default GameGraphics;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}