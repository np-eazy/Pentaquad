{"ast":null,"code":"// A class whose instance acts as a UseState for canvas to listen and hold onto keystrokes, to be consumed by a GameState on its update.\nclass GameController {\n  constructor() {\n    this.actionQueue = [];\n  }\n\n  // TODO: Right now the default keyDown event doesn't immediately repeat keys held down. Change the implementation for certain keys\n  // such that a keyDown event adds to a keyset and a corresponding keyUp event removes from the keyset, and replace consumeAction\n  // with a function that simply returns the mapped actions from the.\n\n  // We should have two types of controls: holdable keys which follow the rule above, and single-press keys which already work as\n  // intended with keyDown. Holdable keys include WASD movement, and single-press keys include SPACE and QE for placing/rotation.\n  handleKeyDown(key) {\n    var action = null;\n    if (key == \"w\") {\n      action = new GameAction(ActionType.MOVE, {\n        angle: 1\n      });\n    } else if (key == \"a\") {\n      action = new GameAction(ActionType.MOVE, {\n        angle: 2\n      });\n    } else if (key == \"s\") {\n      action = new GameAction(ActionType.MOVE, {\n        angle: 3\n      });\n    } else if (key == \"d\") {\n      action = new GameAction(ActionType.MOVE, {\n        angle: 0\n      });\n\n      // TODO: Change handleKeypress to take in the whole event so keyCode can be invoked for arrow keys.\n    } else if (key == \"q\") {\n      action = new GameAction(ActionType.ROTATE, {\n        angle: 1\n      });\n    } else if (key == \"e\") {\n      action = new GameAction(ActionType.ROTATE, {\n        angle: -1\n      });\n    } else if (key == \" \") {\n      action = new GameAction(ActionType.PLACE, {});\n    }\n    if (action != null) {\n      this.actionQueue.push(action);\n    }\n    return this;\n  }\n\n  // Consume the last action registered in the queue.\n  consumeAction() {\n    return this.actionQueue.shift();\n  }\n}\nexport default GameController;","map":{"version":3,"names":["GameController","constructor","actionQueue","handleKeyDown","key","action","GameAction","ActionType","MOVE","angle","ROTATE","PLACE","push","consumeAction","shift"],"sources":["/Users/joeyzhu/code/visuals/pentaquad/src/components/game/GameController.js"],"sourcesContent":["\n// A class whose instance acts as a UseState for canvas to listen and hold onto keystrokes, to be consumed by a GameState on its update.\nclass GameController {\n    constructor() {\n        this.actionQueue = [];\n    }\n\n    // TODO: Right now the default keyDown event doesn't immediately repeat keys held down. Change the implementation for certain keys\n    // such that a keyDown event adds to a keyset and a corresponding keyUp event removes from the keyset, and replace consumeAction\n    // with a function that simply returns the mapped actions from the.\n    \n    // We should have two types of controls: holdable keys which follow the rule above, and single-press keys which already work as\n    // intended with keyDown. Holdable keys include WASD movement, and single-press keys include SPACE and QE for placing/rotation.\n    handleKeyDown(key) {\n        var action = null;\n        if (key == \"w\") {\n            action = new GameAction(ActionType.MOVE, {angle: 1})\n        } else if (key == \"a\") {\n            action = new GameAction(ActionType.MOVE, {angle: 2})\n        } else if (key == \"s\") {\n            action = new GameAction(ActionType.MOVE, {angle: 3})\n        } else if (key == \"d\") {\n            action = new GameAction(ActionType.MOVE, {angle: 0})\n        \n        // TODO: Change handleKeypress to take in the whole event so keyCode can be invoked for arrow keys.\n        } else if (key == \"q\") {\n            action = new GameAction(ActionType.ROTATE, {angle: 1})\n        } else if (key == \"e\") {\n            action = new GameAction(ActionType.ROTATE, {angle: -1})\n\n        } else if (key == \" \") {\n            action = new GameAction(ActionType.PLACE, {})\n        }\n        if (action != null) {\n            this.actionQueue.push(action)\n        }\n        return this;\n    }\n\n    // Consume the last action registered in the queue.\n    consumeAction() {         \n        return this.actionQueue.shift()\n    }\n}\n\nexport default GameController;"],"mappings":"AACA;AACA,MAAMA,cAAc,CAAC;EACjBC,WAAWA,CAAA,EAAG;IACV,IAAI,CAACC,WAAW,GAAG,EAAE;EACzB;;EAEA;EACA;EACA;;EAEA;EACA;EACAC,aAAaA,CAACC,GAAG,EAAE;IACf,IAAIC,MAAM,GAAG,IAAI;IACjB,IAAID,GAAG,IAAI,GAAG,EAAE;MACZC,MAAM,GAAG,IAAIC,UAAU,CAACC,UAAU,CAACC,IAAI,EAAE;QAACC,KAAK,EAAE;MAAC,CAAC,CAAC;IACxD,CAAC,MAAM,IAAIL,GAAG,IAAI,GAAG,EAAE;MACnBC,MAAM,GAAG,IAAIC,UAAU,CAACC,UAAU,CAACC,IAAI,EAAE;QAACC,KAAK,EAAE;MAAC,CAAC,CAAC;IACxD,CAAC,MAAM,IAAIL,GAAG,IAAI,GAAG,EAAE;MACnBC,MAAM,GAAG,IAAIC,UAAU,CAACC,UAAU,CAACC,IAAI,EAAE;QAACC,KAAK,EAAE;MAAC,CAAC,CAAC;IACxD,CAAC,MAAM,IAAIL,GAAG,IAAI,GAAG,EAAE;MACnBC,MAAM,GAAG,IAAIC,UAAU,CAACC,UAAU,CAACC,IAAI,EAAE;QAACC,KAAK,EAAE;MAAC,CAAC,CAAC;;MAExD;IACA,CAAC,MAAM,IAAIL,GAAG,IAAI,GAAG,EAAE;MACnBC,MAAM,GAAG,IAAIC,UAAU,CAACC,UAAU,CAACG,MAAM,EAAE;QAACD,KAAK,EAAE;MAAC,CAAC,CAAC;IAC1D,CAAC,MAAM,IAAIL,GAAG,IAAI,GAAG,EAAE;MACnBC,MAAM,GAAG,IAAIC,UAAU,CAACC,UAAU,CAACG,MAAM,EAAE;QAACD,KAAK,EAAE,CAAC;MAAC,CAAC,CAAC;IAE3D,CAAC,MAAM,IAAIL,GAAG,IAAI,GAAG,EAAE;MACnBC,MAAM,GAAG,IAAIC,UAAU,CAACC,UAAU,CAACI,KAAK,EAAE,CAAC,CAAC,CAAC;IACjD;IACA,IAAIN,MAAM,IAAI,IAAI,EAAE;MAChB,IAAI,CAACH,WAAW,CAACU,IAAI,CAACP,MAAM,CAAC;IACjC;IACA,OAAO,IAAI;EACf;;EAEA;EACAQ,aAAaA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACX,WAAW,CAACY,KAAK,EAAE;EACnC;AACJ;AAEA,eAAed,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}